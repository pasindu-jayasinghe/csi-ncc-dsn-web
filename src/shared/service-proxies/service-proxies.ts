/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.7.1.0 (NJsonSchema v10.1.26.0 (Newtonsoft.Json v11.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

import * as moment from 'moment';

export const API_BASE_URL = new InjectionToken<string>('API_BASE_URL');

@Injectable()
export class AppControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getHello(): Observable<string> {
        let url_ = this.baseUrl + "/";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetHello(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetHello(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetHello(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    login(body: AuthCredentialDto): Observable<any> {
        let url_ = this.baseUrl + "/auth/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    validateResetPassword(email: string, token: string): Observable<boolean> {
        let url_ = this.baseUrl + "/auth/validate-reset-password/{email}/{token}";
        if (email === undefined || email === null)
            throw new Error("The parameter 'email' must be defined.");
        url_ = url_.replace("{email}", encodeURIComponent("" + email));
        if (token === undefined || token === null)
            throw new Error("The parameter 'token' must be defined.");
        url_ = url_.replace("{token}", encodeURIComponent("" + token));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processValidateResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processValidateResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processValidateResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    resetPassword(body: ResetPassword): Observable<boolean> {
        let url_ = this.baseUrl + "/auth/reset-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    forgotPassword(body: ForgotPasswordDto): Observable<any> {
        let url_ = this.baseUrl + "/auth/forgot-password";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processForgotPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processForgotPassword(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processForgotPassword(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getProfile(): Observable<void> {
        let url_ = this.baseUrl + "/profile";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProfile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProfile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processGetProfile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getAdmin(): Observable<string> {
        let url_ = this.baseUrl + "/admin";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAdmin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAdmin(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processGetAdmin(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    getUserInfo(): Observable<User> {
        let url_ = this.baseUrl + "/user-info";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserInfo(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserInfo(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }
}

@Injectable()
export class ChartControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getDatForClimateChangeChart(): Observable<ClimateChangeBarChart[]> {
        let url_ = this.baseUrl + "/chart/chart/ClimateChangeChart";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatForClimateChangeChart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatForClimateChangeChart(<any>response_);
                } catch (e) {
                    return <Observable<ClimateChangeBarChart[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateChangeBarChart[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatForClimateChangeChart(response: HttpResponseBase): Observable<ClimateChangeBarChart[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ClimateChangeBarChart.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateChangeBarChart[]>(<any>null);
    }

    getDataforUserDataUsage(): Observable<ClimateChangeBarChart> {
        let url_ = this.baseUrl + "/chart/chart/UserDataUsage";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataforUserDataUsage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataforUserDataUsage(<any>response_);
                } catch (e) {
                    return <Observable<ClimateChangeBarChart>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateChangeBarChart>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataforUserDataUsage(response: HttpResponseBase): Observable<ClimateChangeBarChart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClimateChangeBarChart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateChangeBarChart>(<any>null);
    }
}

@Injectable()
export class PublicControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getProjectViewPageDetails(page: number, limit: number, name: string, dateofCommence: number, sector: number, ccdCatagary: number, status: number, location: string): Observable<any> {
        let url_ = this.baseUrl + "/public/public-getProjectViewPageDetails/{page}/{limit}/{name}/{dateofCommence}/{sector}/{ccdCatagary}/{status}/{location}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (dateofCommence === undefined || dateofCommence === null)
            throw new Error("The parameter 'dateofCommence' must be defined and cannot be null.");
        else
            url_ += "dateofCommence=" + encodeURIComponent("" + dateofCommence) + "&";
        if (sector === undefined || sector === null)
            throw new Error("The parameter 'sector' must be defined and cannot be null.");
        else
            url_ += "sector=" + encodeURIComponent("" + sector) + "&";
        if (ccdCatagary === undefined || ccdCatagary === null)
            throw new Error("The parameter 'ccdCatagary' must be defined and cannot be null.");
        else
            url_ += "ccdCatagary=" + encodeURIComponent("" + ccdCatagary) + "&";
        if (status === undefined || status === null)
            throw new Error("The parameter 'status' must be defined and cannot be null.");
        else
            url_ += "status=" + encodeURIComponent("" + status) + "&";
        if (location === undefined || location === null)
            throw new Error("The parameter 'location' must be defined and cannot be null.");
        else
            url_ += "location=" + encodeURIComponent("" + location) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectViewPageDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectViewPageDetails(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectViewPageDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getPolicyViewPageDetails(page: number, limit: number, name: string, sector: number, ccdCatagary: number, influenceId: number): Observable<any> {
        let url_ = this.baseUrl + "/public/public-getPolicyViewPageDetails/{page}/{limit}/{name}/{sector}/{ccdCatagary}/{influenceId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (sector === undefined || sector === null)
            throw new Error("The parameter 'sector' must be defined and cannot be null.");
        else
            url_ += "sector=" + encodeURIComponent("" + sector) + "&";
        if (ccdCatagary === undefined || ccdCatagary === null)
            throw new Error("The parameter 'ccdCatagary' must be defined and cannot be null.");
        else
            url_ += "ccdCatagary=" + encodeURIComponent("" + ccdCatagary) + "&";
        if (influenceId === undefined || influenceId === null)
            throw new Error("The parameter 'influenceId' must be defined and cannot be null.");
        else
            url_ += "influenceId=" + encodeURIComponent("" + influenceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPolicyViewPageDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPolicyViewPageDetails(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPolicyViewPageDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getProjectViewinfo(id: number): Observable<ProjectProgramme> {
        let url_ = this.baseUrl + "/public/public-getProjectViewinfo/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined and cannot be null.");
        else
            url_ += "id=" + encodeURIComponent("" + id) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectViewinfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectViewinfo(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramme>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramme>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectViewinfo(response: HttpResponseBase): Observable<ProjectProgramme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectProgramme.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramme>(<any>null);
    }
}

@Injectable()
export class UsersControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    create(body: CreateUserDto): Observable<User> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = User.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    findAll(): Observable<User[]> {
        let url_ = this.baseUrl + "/users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindAll(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processFindAll(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(User.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(<any>null);
    }

    findOne(id: string): Observable<User> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindOne(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processFindOne(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    remove(id: number): Observable<void> {
        let url_ = this.baseUrl + "/users/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemove(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processRemove(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    isUserAvailable(userName: string): Observable<boolean> {
        let url_ = this.baseUrl + "/users/isUserAvailable/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processIsUserAvailable(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processIsUserAvailable(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processIsUserAvailable(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    findUserByUserName(userName: string): Observable<any> {
        let url_ = this.baseUrl + "/users/findUserByUserName/{userName}";
        if (userName === undefined || userName === null)
            throw new Error("The parameter 'userName' must be defined.");
        url_ = url_.replace("{userName}", encodeURIComponent("" + userName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFindUserByUserName(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFindUserByUserName(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processFindUserByUserName(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class ServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    /**
     * Delete one Institution
     */
    deleteOneBaseInstitutionControllerInstitution(id: number): Observable<void> {
        let url_ = this.baseUrl + "/institution/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseInstitutionControllerInstitution(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve one Institution
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseInstitutionControllerInstitution(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Institution> {
        let url_ = this.baseUrl + "/institution/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseInstitutionControllerInstitution(<any>response_);
                } catch (e) {
                    return <Observable<Institution>><any>_observableThrow(e);
                }
            } else
                return <Observable<Institution>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<Institution> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Institution.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Institution>(<any>null);
    }

    /**
     * Update one Institution
     * @return Response
     */
    updateOneBaseInstitutionControllerInstitution(id: number, body: Institution): Observable<Institution> {
        let url_ = this.baseUrl + "/institution/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseInstitutionControllerInstitution(<any>response_);
                } catch (e) {
                    return <Observable<Institution>><any>_observableThrow(e);
                }
            } else
                return <Observable<Institution>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<Institution> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Institution.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Institution>(<any>null);
    }

    /**
     * Replace one Institution
     * @return Response
     */
    replaceOneBaseInstitutionControllerInstitution(id: number, body: Institution): Observable<Institution> {
        let url_ = this.baseUrl + "/institution/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseInstitutionControllerInstitution(<any>response_);
                } catch (e) {
                    return <Observable<Institution>><any>_observableThrow(e);
                }
            } else
                return <Observable<Institution>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<Institution> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Institution.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Institution>(<any>null);
    }

    /**
     * Retrieve many Institution
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseInstitutionControllerInstitution(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyInstitutionResponseDto> {
        let url_ = this.baseUrl + "/institution?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseInstitutionControllerInstitution(<any>response_);
                } catch (e) {
                    return <Observable<GetManyInstitutionResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyInstitutionResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<GetManyInstitutionResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyInstitutionResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyInstitutionResponseDto>(<any>null);
    }

    /**
     * Create one Institution
     * @return Get create one base response
     */
    createOneBaseInstitutionControllerInstitution(body: Institution): Observable<Institution> {
        let url_ = this.baseUrl + "/institution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseInstitutionControllerInstitution(<any>response_);
                } catch (e) {
                    return <Observable<Institution>><any>_observableThrow(e);
                }
            } else
                return <Observable<Institution>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<Institution> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Institution.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Institution>(<any>null);
    }

    /**
     * Create many Institution
     * @return Get create many base response
     */
    createManyBaseInstitutionControllerInstitution(body: CreateManyInstitutionDto): Observable<Institution[]> {
        let url_ = this.baseUrl + "/institution/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseInstitutionControllerInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseInstitutionControllerInstitution(<any>response_);
                } catch (e) {
                    return <Observable<Institution[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Institution[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseInstitutionControllerInstitution(response: HttpResponseBase): Observable<Institution[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Institution.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Institution[]>(<any>null);
    }

    /**
     * Create many ProjectProgramData
     * @return Get create many base response
     */
    createManyBaseProjectProgramDataControllerProjectProgramDataAll(body: CreateManyProjectProgramDataDto): Observable<ProjectProgramData[]> {
        let url_ = this.baseUrl + "/undefined";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("undefined", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectProgramDataControllerProjectProgramDataAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectProgramDataControllerProjectProgramDataAll(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramData[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseProjectProgramDataControllerProjectProgramDataAll(response: HttpResponseBase): Observable<ProjectProgramData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectProgramData.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramData[]>(<any>null);
    }

    /**
     * Retrieve one UserType
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUserTypeControllerUserType(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<UserType> {
        let url_ = this.baseUrl + "/usertype/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUserTypeControllerUserType(<any>response_);
                } catch (e) {
                    return <Observable<UserType>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserType>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<UserType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserType>(<any>null);
    }

    /**
     * Update one UserType
     * @return Response
     */
    updateOneBaseUserTypeControllerUserType(id: number, body: UserType): Observable<UserType> {
        let url_ = this.baseUrl + "/usertype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUserTypeControllerUserType(<any>response_);
                } catch (e) {
                    return <Observable<UserType>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserType>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<UserType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserType>(<any>null);
    }

    /**
     * Replace one UserType
     * @return Response
     */
    replaceOneBaseUserTypeControllerUserType(id: number, body: UserType): Observable<UserType> {
        let url_ = this.baseUrl + "/usertype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUserTypeControllerUserType(<any>response_);
                } catch (e) {
                    return <Observable<UserType>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserType>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<UserType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserType.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserType>(<any>null);
    }

    /**
     * Delete one UserType
     * @return Delete one base response
     */
    deleteOneBaseUserTypeControllerUserType(id: number): Observable<void> {
        let url_ = this.baseUrl + "/usertype/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUserTypeControllerUserType(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many UserType
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUserTypeControllerUserType(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUserTypeResponseDto> {
        let url_ = this.baseUrl + "/usertype?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUserTypeControllerUserType(<any>response_);
                } catch (e) {
                    return <Observable<GetManyUserTypeResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyUserTypeResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<GetManyUserTypeResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUserTypeResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyUserTypeResponseDto>(<any>null);
    }

    /**
     * Create one UserType
     * @return Get create one base response
     */
    createOneBaseUserTypeControllerUserType(body: UserType): Observable<UserType> {
        let url_ = this.baseUrl + "/usertype";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUserTypeControllerUserType(<any>response_);
                } catch (e) {
                    return <Observable<UserType>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserType>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<UserType> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UserType.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserType>(<any>null);
    }

    /**
     * Create many UserType
     * @return Get create many base response
     */
    createManyBaseUserTypeControllerUserType(body: CreateManyUserTypeDto): Observable<UserType[]> {
        let url_ = this.baseUrl + "/usertype/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUserTypeControllerUserType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUserTypeControllerUserType(<any>response_);
                } catch (e) {
                    return <Observable<UserType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserType[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseUserTypeControllerUserType(response: HttpResponseBase): Observable<UserType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(UserType.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserType[]>(<any>null);
    }

    /**
     * Retrieve one Mitigation
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseMitigationControllerMitigation(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Mitigation> {
        let url_ = this.baseUrl + "/mitigation/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseMitigationControllerMitigation(<any>response_);
                } catch (e) {
                    return <Observable<Mitigation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Mitigation>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<Mitigation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Mitigation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Mitigation>(<any>null);
    }

    /**
     * Update one Mitigation
     * @return Response
     */
    updateOneBaseMitigationControllerMitigation(id: number, body: Mitigation): Observable<Mitigation> {
        let url_ = this.baseUrl + "/mitigation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseMitigationControllerMitigation(<any>response_);
                } catch (e) {
                    return <Observable<Mitigation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Mitigation>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<Mitigation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Mitigation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Mitigation>(<any>null);
    }

    /**
     * Replace one Mitigation
     * @return Response
     */
    replaceOneBaseMitigationControllerMitigation(id: number, body: Mitigation): Observable<Mitigation> {
        let url_ = this.baseUrl + "/mitigation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseMitigationControllerMitigation(<any>response_);
                } catch (e) {
                    return <Observable<Mitigation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Mitigation>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<Mitigation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Mitigation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Mitigation>(<any>null);
    }

    /**
     * Delete one Mitigation
     * @return Delete one base response
     */
    deleteOneBaseMitigationControllerMitigation(id: number): Observable<void> {
        let url_ = this.baseUrl + "/mitigation/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseMitigationControllerMitigation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many Mitigation
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseMitigationControllerMitigation(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyMitigationResponseDto> {
        let url_ = this.baseUrl + "/mitigation?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseMitigationControllerMitigation(<any>response_);
                } catch (e) {
                    return <Observable<GetManyMitigationResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyMitigationResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<GetManyMitigationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyMitigationResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyMitigationResponseDto>(<any>null);
    }

    /**
     * Create one Mitigation
     * @return Get create one base response
     */
    createOneBaseMitigationControllerMitigation(body: Mitigation): Observable<Mitigation> {
        let url_ = this.baseUrl + "/mitigation";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseMitigationControllerMitigation(<any>response_);
                } catch (e) {
                    return <Observable<Mitigation>><any>_observableThrow(e);
                }
            } else
                return <Observable<Mitigation>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<Mitigation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Mitigation.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Mitigation>(<any>null);
    }

    /**
     * Create many Mitigation
     * @return Get create many base response
     */
    createManyBaseMitigationControllerMitigation(body: CreateManyMitigationDto): Observable<Mitigation[]> {
        let url_ = this.baseUrl + "/mitigation/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseMitigationControllerMitigation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseMitigationControllerMitigation(<any>response_);
                } catch (e) {
                    return <Observable<Mitigation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Mitigation[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseMitigationControllerMitigation(response: HttpResponseBase): Observable<Mitigation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Mitigation.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Mitigation[]>(<any>null);
    }

    /**
     * Create one UomConversion
     */
    createOneBaseUomConversionControllerUomConversion(body: UomConversion): Observable<void> {
        let url_ = this.baseUrl + "/uom-conversion";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUomConversionControllerUomConversion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUomConversionControllerUomConversion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseUomConversionControllerUomConversion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UomConversion.fromJS(resultData201);
            return throwException("Get create one base response", status, _responseText, _headers, result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many UomConversion
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUomConversionControllerUomConversion(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUomConversionResponseDto> {
        let url_ = this.baseUrl + "/uom-conversion?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUomConversionControllerUomConversion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUomConversionControllerUomConversion(<any>response_);
                } catch (e) {
                    return <Observable<GetManyUomConversionResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyUomConversionResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseUomConversionControllerUomConversion(response: HttpResponseBase): Observable<GetManyUomConversionResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUomConversionResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyUomConversionResponseDto>(<any>null);
    }

    /**
     * Update one UomConversion
     */
    updateOneBaseUomConversionControllerUomConversion(id: number, body: UomConversion): Observable<void> {
        let url_ = this.baseUrl + "/uom-conversion/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUomConversionControllerUomConversion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUomConversionControllerUomConversion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseUomConversionControllerUomConversion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve one UomConversion
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUomConversionControllerUomConversion(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<UomConversion> {
        let url_ = this.baseUrl + "/uom-conversion/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUomConversionControllerUomConversion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUomConversionControllerUomConversion(<any>response_);
                } catch (e) {
                    return <Observable<UomConversion>><any>_observableThrow(e);
                }
            } else
                return <Observable<UomConversion>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseUomConversionControllerUomConversion(response: HttpResponseBase): Observable<UomConversion> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UomConversion.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UomConversion>(<any>null);
    }

    /**
     * Replace one UomConversion
     * @return Response
     */
    replaceOneBaseUomConversionControllerUomConversion(id: number, body: UomConversion): Observable<UomConversion> {
        let url_ = this.baseUrl + "/uom-conversion/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUomConversionControllerUomConversion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUomConversionControllerUomConversion(<any>response_);
                } catch (e) {
                    return <Observable<UomConversion>><any>_observableThrow(e);
                }
            } else
                return <Observable<UomConversion>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseUomConversionControllerUomConversion(response: HttpResponseBase): Observable<UomConversion> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UomConversion.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UomConversion>(<any>null);
    }

    /**
     * Delete one UomConversion
     * @return Delete one base response
     */
    deleteOneBaseUomConversionControllerUomConversion(id: number): Observable<void> {
        let url_ = this.baseUrl + "/uom-conversion/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUomConversionControllerUomConversion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUomConversionControllerUomConversion(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseUomConversionControllerUomConversion(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create many UomConversion
     * @return Get create many base response
     */
    createManyBaseUomConversionControllerUomConversion(body: CreateManyUomConversionDto): Observable<UomConversion[]> {
        let url_ = this.baseUrl + "/uom-conversion/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUomConversionControllerUomConversion(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUomConversionControllerUomConversion(<any>response_);
                } catch (e) {
                    return <Observable<UomConversion[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UomConversion[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseUomConversionControllerUomConversion(response: HttpResponseBase): Observable<UomConversion[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(UomConversion.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UomConversion[]>(<any>null);
    }

    /**
     * Retrieve one ClimateImpact
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseCcImpactControllerClimateImpact(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ClimateImpact> {
        let url_ = this.baseUrl + "/cc-impact/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseCcImpactControllerClimateImpact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseCcImpactControllerClimateImpact(<any>response_);
                } catch (e) {
                    return <Observable<ClimateImpact>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateImpact>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseCcImpactControllerClimateImpact(response: HttpResponseBase): Observable<ClimateImpact> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClimateImpact.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateImpact>(<any>null);
    }

    /**
     * Update one ClimateImpact
     * @return Response
     */
    updateOneBaseCcImpactControllerClimateImpact(id: number, body: ClimateImpact): Observable<ClimateImpact> {
        let url_ = this.baseUrl + "/cc-impact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseCcImpactControllerClimateImpact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseCcImpactControllerClimateImpact(<any>response_);
                } catch (e) {
                    return <Observable<ClimateImpact>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateImpact>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseCcImpactControllerClimateImpact(response: HttpResponseBase): Observable<ClimateImpact> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClimateImpact.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateImpact>(<any>null);
    }

    /**
     * Replace one ClimateImpact
     * @return Response
     */
    replaceOneBaseCcImpactControllerClimateImpact(id: number, body: ClimateImpact): Observable<ClimateImpact> {
        let url_ = this.baseUrl + "/cc-impact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseCcImpactControllerClimateImpact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseCcImpactControllerClimateImpact(<any>response_);
                } catch (e) {
                    return <Observable<ClimateImpact>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateImpact>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseCcImpactControllerClimateImpact(response: HttpResponseBase): Observable<ClimateImpact> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClimateImpact.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateImpact>(<any>null);
    }

    /**
     * Delete one ClimateImpact
     * @return Delete one base response
     */
    deleteOneBaseCcImpactControllerClimateImpact(id: number): Observable<void> {
        let url_ = this.baseUrl + "/cc-impact/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseCcImpactControllerClimateImpact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseCcImpactControllerClimateImpact(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseCcImpactControllerClimateImpact(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many ClimateImpact
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseCcImpactControllerClimateImpact(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyClimateImpactResponseDto> {
        let url_ = this.baseUrl + "/cc-impact?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseCcImpactControllerClimateImpact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseCcImpactControllerClimateImpact(<any>response_);
                } catch (e) {
                    return <Observable<GetManyClimateImpactResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyClimateImpactResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseCcImpactControllerClimateImpact(response: HttpResponseBase): Observable<GetManyClimateImpactResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyClimateImpactResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyClimateImpactResponseDto>(<any>null);
    }

    /**
     * Create one ClimateImpact
     * @return Get create one base response
     */
    createOneBaseCcImpactControllerClimateImpact(body: ClimateImpact): Observable<ClimateImpact> {
        let url_ = this.baseUrl + "/cc-impact";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseCcImpactControllerClimateImpact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseCcImpactControllerClimateImpact(<any>response_);
                } catch (e) {
                    return <Observable<ClimateImpact>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateImpact>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseCcImpactControllerClimateImpact(response: HttpResponseBase): Observable<ClimateImpact> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClimateImpact.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateImpact>(<any>null);
    }

    /**
     * Create many ClimateImpact
     * @return Get create many base response
     */
    createManyBaseCcImpactControllerClimateImpact(body: CreateManyClimateImpactDto): Observable<ClimateImpact[]> {
        let url_ = this.baseUrl + "/cc-impact/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseCcImpactControllerClimateImpact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseCcImpactControllerClimateImpact(<any>response_);
                } catch (e) {
                    return <Observable<ClimateImpact[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateImpact[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseCcImpactControllerClimateImpact(response: HttpResponseBase): Observable<ClimateImpact[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ClimateImpact.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateImpact[]>(<any>null);
    }

    /**
     * Delete one User
     */
    deleteOneBaseUserv2ControllerUser(id: number): Observable<void> {
        let url_ = this.baseUrl + "/userv2/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUserv2ControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUserv2ControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseUserv2ControllerUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve one User
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     */
    getOneBaseUserv2ControllerUser(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<User> {
        let url_ = this.baseUrl + "/userv2/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUserv2ControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUserv2ControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseUserv2ControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * Update one User
     * @return Response
     */
    updateOneBaseUserv2ControllerUser(id: number, body: User): Observable<User> {
        let url_ = this.baseUrl + "/userv2/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUserv2ControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUserv2ControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseUserv2ControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * Replace one User
     * @return Response
     */
    replaceOneBaseUserv2ControllerUser(id: number, body: User): Observable<User> {
        let url_ = this.baseUrl + "/userv2/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUserv2ControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUserv2ControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseUserv2ControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * Retrieve many User
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     */
    getManyBaseUserv2ControllerUser(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<any> {
        let url_ = this.baseUrl + "/userv2?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUserv2ControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUserv2ControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseUserv2ControllerUser(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Create one User
     */
    createOneBaseUserv2ControllerUser(body: User): Observable<User> {
        let url_ = this.baseUrl + "/userv2";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUserv2ControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUserv2ControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<User>><any>_observableThrow(e);
                }
            } else
                return <Observable<User>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseUserv2ControllerUser(response: HttpResponseBase): Observable<User> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = User.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = User.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User>(<any>null);
    }

    /**
     * Create many User
     * @return Get create many base response
     */
    createManyBaseUserv2ControllerUser(body: CreateManyUserDto): Observable<User[]> {
        let url_ = this.baseUrl + "/userv2/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUserv2ControllerUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUserv2ControllerUser(<any>response_);
                } catch (e) {
                    return <Observable<User[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<User[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseUserv2ControllerUser(response: HttpResponseBase): Observable<User[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(User.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<User[]>(<any>null);
    }

    /**
     * Create one Parameter
     */
    createOneBaseParameterControllerParameter(body: Parameter): Observable<Parameter> {
        let url_ = this.baseUrl + "/parameter";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseParameterControllerParameter(<any>response_);
                } catch (e) {
                    return <Observable<Parameter>><any>_observableThrow(e);
                }
            } else
                return <Observable<Parameter>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseParameterControllerParameter(response: HttpResponseBase): Observable<Parameter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Parameter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Parameter.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Parameter>(<any>null);
    }

    /**
     * Retrieve many Parameter
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseParameterControllerParameter(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyParameterResponseDto> {
        let url_ = this.baseUrl + "/parameter?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseParameterControllerParameter(<any>response_);
                } catch (e) {
                    return <Observable<GetManyParameterResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyParameterResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseParameterControllerParameter(response: HttpResponseBase): Observable<GetManyParameterResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyParameterResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyParameterResponseDto>(<any>null);
    }

    /**
     * Delete one Parameter
     */
    deleteOneBaseParameterControllerParameter(id: number): Observable<void> {
        let url_ = this.baseUrl + "/parameter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseParameterControllerParameter(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseParameterControllerParameter(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve one Parameter
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseParameterControllerParameter(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Parameter> {
        let url_ = this.baseUrl + "/parameter/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseParameterControllerParameter(<any>response_);
                } catch (e) {
                    return <Observable<Parameter>><any>_observableThrow(e);
                }
            } else
                return <Observable<Parameter>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseParameterControllerParameter(response: HttpResponseBase): Observable<Parameter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Parameter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Parameter>(<any>null);
    }

    /**
     * Update one Parameter
     * @return Response
     */
    updateOneBaseParameterControllerParameter(id: number, body: Parameter): Observable<Parameter> {
        let url_ = this.baseUrl + "/parameter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseParameterControllerParameter(<any>response_);
                } catch (e) {
                    return <Observable<Parameter>><any>_observableThrow(e);
                }
            } else
                return <Observable<Parameter>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseParameterControllerParameter(response: HttpResponseBase): Observable<Parameter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Parameter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Parameter>(<any>null);
    }

    /**
     * Replace one Parameter
     * @return Response
     */
    replaceOneBaseParameterControllerParameter(id: number, body: Parameter): Observable<Parameter> {
        let url_ = this.baseUrl + "/parameter/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseParameterControllerParameter(<any>response_);
                } catch (e) {
                    return <Observable<Parameter>><any>_observableThrow(e);
                }
            } else
                return <Observable<Parameter>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseParameterControllerParameter(response: HttpResponseBase): Observable<Parameter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Parameter.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Parameter>(<any>null);
    }

    /**
     * Create many Parameter
     * @return Get create many base response
     */
    createManyBaseParameterControllerParameter(body: CreateManyParameterDto): Observable<Parameter[]> {
        let url_ = this.baseUrl + "/parameter/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseParameterControllerParameter(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseParameterControllerParameter(<any>response_);
                } catch (e) {
                    return <Observable<Parameter[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Parameter[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseParameterControllerParameter(response: HttpResponseBase): Observable<Parameter[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Parameter.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Parameter[]>(<any>null);
    }

    /**
     * Create one UnitOfMeasure
     */
    createOneBaseUnitOfMeasureControllerUnitOfMeasure(body: UnitOfMeasure): Observable<UnitOfMeasure> {
        let url_ = this.baseUrl + "/unit-of-measure";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUnitOfMeasureControllerUnitOfMeasure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUnitOfMeasureControllerUnitOfMeasure(<any>response_);
                } catch (e) {
                    return <Observable<UnitOfMeasure>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitOfMeasure>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseUnitOfMeasureControllerUnitOfMeasure(response: HttpResponseBase): Observable<UnitOfMeasure> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitOfMeasure.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UnitOfMeasure.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasure>(<any>null);
    }

    /**
     * Retrieve many UnitOfMeasure
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUnitOfMeasureControllerUnitOfMeasure(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUnitOfMeasureResponseDto> {
        let url_ = this.baseUrl + "/unit-of-measure?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUnitOfMeasureControllerUnitOfMeasure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUnitOfMeasureControllerUnitOfMeasure(<any>response_);
                } catch (e) {
                    return <Observable<GetManyUnitOfMeasureResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyUnitOfMeasureResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseUnitOfMeasureControllerUnitOfMeasure(response: HttpResponseBase): Observable<GetManyUnitOfMeasureResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUnitOfMeasureResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyUnitOfMeasureResponseDto>(<any>null);
    }

    /**
     * Update one UnitOfMeasure
     */
    updateOneBaseUnitOfMeasureControllerUnitOfMeasure(id: number, body: UnitOfMeasure): Observable<UnitOfMeasure> {
        let url_ = this.baseUrl + "/unit-of-measure/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUnitOfMeasureControllerUnitOfMeasure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUnitOfMeasureControllerUnitOfMeasure(<any>response_);
                } catch (e) {
                    return <Observable<UnitOfMeasure>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitOfMeasure>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseUnitOfMeasureControllerUnitOfMeasure(response: HttpResponseBase): Observable<UnitOfMeasure> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitOfMeasure.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasure>(<any>null);
    }

    /**
     * Retrieve one UnitOfMeasure
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUnitOfMeasureControllerUnitOfMeasure(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<UnitOfMeasure> {
        let url_ = this.baseUrl + "/unit-of-measure/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUnitOfMeasureControllerUnitOfMeasure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUnitOfMeasureControllerUnitOfMeasure(<any>response_);
                } catch (e) {
                    return <Observable<UnitOfMeasure>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitOfMeasure>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseUnitOfMeasureControllerUnitOfMeasure(response: HttpResponseBase): Observable<UnitOfMeasure> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitOfMeasure.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasure>(<any>null);
    }

    /**
     * Replace one UnitOfMeasure
     * @return Response
     */
    replaceOneBaseUnitOfMeasureControllerUnitOfMeasure(id: number, body: UnitOfMeasure): Observable<UnitOfMeasure> {
        let url_ = this.baseUrl + "/unit-of-measure/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUnitOfMeasureControllerUnitOfMeasure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUnitOfMeasureControllerUnitOfMeasure(<any>response_);
                } catch (e) {
                    return <Observable<UnitOfMeasure>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitOfMeasure>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseUnitOfMeasureControllerUnitOfMeasure(response: HttpResponseBase): Observable<UnitOfMeasure> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UnitOfMeasure.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasure>(<any>null);
    }

    /**
     * Delete one UnitOfMeasure
     * @return Delete one base response
     */
    deleteOneBaseUnitOfMeasureControllerUnitOfMeasure(id: number): Observable<void> {
        let url_ = this.baseUrl + "/unit-of-measure/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUnitOfMeasureControllerUnitOfMeasure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUnitOfMeasureControllerUnitOfMeasure(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseUnitOfMeasureControllerUnitOfMeasure(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create many UnitOfMeasure
     * @return Get create many base response
     */
    createManyBaseUnitOfMeasureControllerUnitOfMeasure(body: CreateManyUnitOfMeasureDto): Observable<UnitOfMeasure[]> {
        let url_ = this.baseUrl + "/unit-of-measure/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUnitOfMeasureControllerUnitOfMeasure(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUnitOfMeasureControllerUnitOfMeasure(<any>response_);
                } catch (e) {
                    return <Observable<UnitOfMeasure[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnitOfMeasure[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseUnitOfMeasureControllerUnitOfMeasure(response: HttpResponseBase): Observable<UnitOfMeasure[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(UnitOfMeasure.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnitOfMeasure[]>(<any>null);
    }

    /**
     * Retrieve one ClimateChangeDataCategory
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ClimateChangeDataCategory> {
        let url_ = this.baseUrl + "/climate-change-data-category/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(<any>response_);
                } catch (e) {
                    return <Observable<ClimateChangeDataCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateChangeDataCategory>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response: HttpResponseBase): Observable<ClimateChangeDataCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClimateChangeDataCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateChangeDataCategory>(<any>null);
    }

    /**
     * Update one ClimateChangeDataCategory
     * @return Response
     */
    updateOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(id: number, body: ClimateChangeDataCategory): Observable<ClimateChangeDataCategory> {
        let url_ = this.baseUrl + "/climate-change-data-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(<any>response_);
                } catch (e) {
                    return <Observable<ClimateChangeDataCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateChangeDataCategory>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response: HttpResponseBase): Observable<ClimateChangeDataCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClimateChangeDataCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateChangeDataCategory>(<any>null);
    }

    /**
     * Replace one ClimateChangeDataCategory
     * @return Response
     */
    replaceOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(id: number, body: ClimateChangeDataCategory): Observable<ClimateChangeDataCategory> {
        let url_ = this.baseUrl + "/climate-change-data-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(<any>response_);
                } catch (e) {
                    return <Observable<ClimateChangeDataCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateChangeDataCategory>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response: HttpResponseBase): Observable<ClimateChangeDataCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ClimateChangeDataCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateChangeDataCategory>(<any>null);
    }

    /**
     * Delete one ClimateChangeDataCategory
     * @return Delete one base response
     */
    deleteOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(id: number): Observable<void> {
        let url_ = this.baseUrl + "/climate-change-data-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many ClimateChangeDataCategory
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyClimateChangeDataCategoryResponseDto> {
        let url_ = this.baseUrl + "/climate-change-data-category?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(<any>response_);
                } catch (e) {
                    return <Observable<GetManyClimateChangeDataCategoryResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyClimateChangeDataCategoryResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response: HttpResponseBase): Observable<GetManyClimateChangeDataCategoryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyClimateChangeDataCategoryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyClimateChangeDataCategoryResponseDto>(<any>null);
    }

    /**
     * Create one ClimateChangeDataCategory
     * @return Get create one base response
     */
    createOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(body: ClimateChangeDataCategory): Observable<ClimateChangeDataCategory> {
        let url_ = this.baseUrl + "/climate-change-data-category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(<any>response_);
                } catch (e) {
                    return <Observable<ClimateChangeDataCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateChangeDataCategory>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response: HttpResponseBase): Observable<ClimateChangeDataCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ClimateChangeDataCategory.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateChangeDataCategory>(<any>null);
    }

    /**
     * Create many ClimateChangeDataCategory
     * @return Get create many base response
     */
    createManyBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(body: CreateManyClimateChangeDataCategoryDto): Observable<ClimateChangeDataCategory[]> {
        let url_ = this.baseUrl + "/climate-change-data-category/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(<any>response_);
                } catch (e) {
                    return <Observable<ClimateChangeDataCategory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateChangeDataCategory[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseClimateChangeDataCategoryControllerClimateChangeDataCategory(response: HttpResponseBase): Observable<ClimateChangeDataCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ClimateChangeDataCategory.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateChangeDataCategory[]>(<any>null);
    }

    /**
     * Create one Sector
     */
    createOneBaseSectorControllerSector(body: Sector): Observable<Sector> {
        let url_ = this.baseUrl + "/sector";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseSectorControllerSector(<any>response_);
                } catch (e) {
                    return <Observable<Sector>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sector>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseSectorControllerSector(response: HttpResponseBase): Observable<Sector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sector.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Sector.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sector>(<any>null);
    }

    /**
     * Retrieve many Sector
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseSectorControllerSector(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManySectorResponseDto> {
        let url_ = this.baseUrl + "/sector?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseSectorControllerSector(<any>response_);
                } catch (e) {
                    return <Observable<GetManySectorResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManySectorResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseSectorControllerSector(response: HttpResponseBase): Observable<GetManySectorResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManySectorResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManySectorResponseDto>(<any>null);
    }

    /**
     * Update one Sector
     */
    updateOneBaseSectorControllerSector(id: number, body: Sector): Observable<Sector> {
        let url_ = this.baseUrl + "/sector/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseSectorControllerSector(<any>response_);
                } catch (e) {
                    return <Observable<Sector>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sector>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseSectorControllerSector(response: HttpResponseBase): Observable<Sector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sector.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sector>(<any>null);
    }

    /**
     * Retrieve one Sector
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseSectorControllerSector(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Sector> {
        let url_ = this.baseUrl + "/sector/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseSectorControllerSector(<any>response_);
                } catch (e) {
                    return <Observable<Sector>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sector>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseSectorControllerSector(response: HttpResponseBase): Observable<Sector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sector.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sector>(<any>null);
    }

    /**
     * Replace one Sector
     * @return Response
     */
    replaceOneBaseSectorControllerSector(id: number, body: Sector): Observable<Sector> {
        let url_ = this.baseUrl + "/sector/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseSectorControllerSector(<any>response_);
                } catch (e) {
                    return <Observable<Sector>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sector>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseSectorControllerSector(response: HttpResponseBase): Observable<Sector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Sector.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sector>(<any>null);
    }

    /**
     * Delete one Sector
     * @return Delete one base response
     */
    deleteOneBaseSectorControllerSector(id: number): Observable<void> {
        let url_ = this.baseUrl + "/sector/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseSectorControllerSector(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseSectorControllerSector(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create many Sector
     * @return Get create many base response
     */
    createManyBaseSectorControllerSector(body: CreateManySectorDto): Observable<Sector[]> {
        let url_ = this.baseUrl + "/sector/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseSectorControllerSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseSectorControllerSector(<any>response_);
                } catch (e) {
                    return <Observable<Sector[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sector[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseSectorControllerSector(response: HttpResponseBase): Observable<Sector[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Sector.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sector[]>(<any>null);
    }

    /**
     * Retrieve one SubSector
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseSubSectorControllerSubSector(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<SubSector> {
        let url_ = this.baseUrl + "/sub-sector/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseSubSectorControllerSubSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseSubSectorControllerSubSector(<any>response_);
                } catch (e) {
                    return <Observable<SubSector>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubSector>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseSubSectorControllerSubSector(response: HttpResponseBase): Observable<SubSector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubSector.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubSector>(<any>null);
    }

    /**
     * Update one SubSector
     * @return Response
     */
    updateOneBaseSubSectorControllerSubSector(id: number, body: SubSector): Observable<SubSector> {
        let url_ = this.baseUrl + "/sub-sector/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseSubSectorControllerSubSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseSubSectorControllerSubSector(<any>response_);
                } catch (e) {
                    return <Observable<SubSector>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubSector>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseSubSectorControllerSubSector(response: HttpResponseBase): Observable<SubSector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubSector.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubSector>(<any>null);
    }

    /**
     * Replace one SubSector
     * @return Response
     */
    replaceOneBaseSubSectorControllerSubSector(id: number, body: SubSector): Observable<SubSector> {
        let url_ = this.baseUrl + "/sub-sector/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseSubSectorControllerSubSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseSubSectorControllerSubSector(<any>response_);
                } catch (e) {
                    return <Observable<SubSector>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubSector>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseSubSectorControllerSubSector(response: HttpResponseBase): Observable<SubSector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SubSector.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubSector>(<any>null);
    }

    /**
     * Delete one SubSector
     * @return Delete one base response
     */
    deleteOneBaseSubSectorControllerSubSector(id: number): Observable<void> {
        let url_ = this.baseUrl + "/sub-sector/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseSubSectorControllerSubSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseSubSectorControllerSubSector(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseSubSectorControllerSubSector(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many SubSector
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseSubSectorControllerSubSector(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManySubSectorResponseDto> {
        let url_ = this.baseUrl + "/sub-sector?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseSubSectorControllerSubSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseSubSectorControllerSubSector(<any>response_);
                } catch (e) {
                    return <Observable<GetManySubSectorResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManySubSectorResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseSubSectorControllerSubSector(response: HttpResponseBase): Observable<GetManySubSectorResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManySubSectorResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManySubSectorResponseDto>(<any>null);
    }

    /**
     * Create one SubSector
     * @return Get create one base response
     */
    createOneBaseSubSectorControllerSubSector(body: SubSector): Observable<SubSector> {
        let url_ = this.baseUrl + "/sub-sector";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseSubSectorControllerSubSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseSubSectorControllerSubSector(<any>response_);
                } catch (e) {
                    return <Observable<SubSector>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubSector>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseSubSectorControllerSubSector(response: HttpResponseBase): Observable<SubSector> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SubSector.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubSector>(<any>null);
    }

    /**
     * Create many SubSector
     * @return Get create many base response
     */
    createManyBaseSubSectorControllerSubSector(body: CreateManySubSectorDto): Observable<SubSector[]> {
        let url_ = this.baseUrl + "/sub-sector/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseSubSectorControllerSubSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseSubSectorControllerSubSector(<any>response_);
                } catch (e) {
                    return <Observable<SubSector[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubSector[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseSubSectorControllerSubSector(response: HttpResponseBase): Observable<SubSector[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(SubSector.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubSector[]>(<any>null);
    }

    /**
     * Retrieve one SectorMOE
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseSectorMOEControllerSectorMOE(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<SectorMOE> {
        let url_ = this.baseUrl + "/sector-moe/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseSectorMOEControllerSectorMOE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseSectorMOEControllerSectorMOE(<any>response_);
                } catch (e) {
                    return <Observable<SectorMOE>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectorMOE>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseSectorMOEControllerSectorMOE(response: HttpResponseBase): Observable<SectorMOE> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectorMOE.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectorMOE>(<any>null);
    }

    /**
     * Update one SectorMOE
     * @return Response
     */
    updateOneBaseSectorMOEControllerSectorMOE(id: number, body: SectorMOE): Observable<SectorMOE> {
        let url_ = this.baseUrl + "/sector-moe/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseSectorMOEControllerSectorMOE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseSectorMOEControllerSectorMOE(<any>response_);
                } catch (e) {
                    return <Observable<SectorMOE>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectorMOE>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseSectorMOEControllerSectorMOE(response: HttpResponseBase): Observable<SectorMOE> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectorMOE.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectorMOE>(<any>null);
    }

    /**
     * Replace one SectorMOE
     * @return Response
     */
    replaceOneBaseSectorMOEControllerSectorMOE(id: number, body: SectorMOE): Observable<SectorMOE> {
        let url_ = this.baseUrl + "/sector-moe/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseSectorMOEControllerSectorMOE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseSectorMOEControllerSectorMOE(<any>response_);
                } catch (e) {
                    return <Observable<SectorMOE>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectorMOE>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseSectorMOEControllerSectorMOE(response: HttpResponseBase): Observable<SectorMOE> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SectorMOE.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectorMOE>(<any>null);
    }

    /**
     * Delete one SectorMOE
     * @return Delete one base response
     */
    deleteOneBaseSectorMOEControllerSectorMOE(id: number): Observable<void> {
        let url_ = this.baseUrl + "/sector-moe/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseSectorMOEControllerSectorMOE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseSectorMOEControllerSectorMOE(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseSectorMOEControllerSectorMOE(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many SectorMOE
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseSectorMOEControllerSectorMOE(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManySectorMOEResponseDto> {
        let url_ = this.baseUrl + "/sector-moe?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseSectorMOEControllerSectorMOE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseSectorMOEControllerSectorMOE(<any>response_);
                } catch (e) {
                    return <Observable<GetManySectorMOEResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManySectorMOEResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseSectorMOEControllerSectorMOE(response: HttpResponseBase): Observable<GetManySectorMOEResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManySectorMOEResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManySectorMOEResponseDto>(<any>null);
    }

    /**
     * Create one SectorMOE
     * @return Get create one base response
     */
    createOneBaseSectorMOEControllerSectorMOE(body: SectorMOE): Observable<SectorMOE> {
        let url_ = this.baseUrl + "/sector-moe";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseSectorMOEControllerSectorMOE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseSectorMOEControllerSectorMOE(<any>response_);
                } catch (e) {
                    return <Observable<SectorMOE>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectorMOE>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseSectorMOEControllerSectorMOE(response: HttpResponseBase): Observable<SectorMOE> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = SectorMOE.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectorMOE>(<any>null);
    }

    /**
     * Create many SectorMOE
     * @return Get create many base response
     */
    createManyBaseSectorMOEControllerSectorMOE(body: CreateManySectorMOEDto): Observable<SectorMOE[]> {
        let url_ = this.baseUrl + "/sector-moe/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseSectorMOEControllerSectorMOE(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseSectorMOEControllerSectorMOE(<any>response_);
                } catch (e) {
                    return <Observable<SectorMOE[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SectorMOE[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseSectorMOEControllerSectorMOE(response: HttpResponseBase): Observable<SectorMOE[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(SectorMOE.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SectorMOE[]>(<any>null);
    }

    /**
     * Retrieve one ParameterLocation
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseParameterLocationControllerParameterLocation(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ParameterLocation> {
        let url_ = this.baseUrl + "/parameter-location/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseParameterLocationControllerParameterLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseParameterLocationControllerParameterLocation(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocation>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocation>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseParameterLocationControllerParameterLocation(response: HttpResponseBase): Observable<ParameterLocation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterLocation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocation>(<any>null);
    }

    /**
     * Update one ParameterLocation
     * @return Response
     */
    updateOneBaseParameterLocationControllerParameterLocation(id: number, body: ParameterLocation): Observable<ParameterLocation> {
        let url_ = this.baseUrl + "/parameter-location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseParameterLocationControllerParameterLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseParameterLocationControllerParameterLocation(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocation>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocation>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseParameterLocationControllerParameterLocation(response: HttpResponseBase): Observable<ParameterLocation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterLocation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocation>(<any>null);
    }

    /**
     * Replace one ParameterLocation
     * @return Response
     */
    replaceOneBaseParameterLocationControllerParameterLocation(id: number, body: ParameterLocation): Observable<ParameterLocation> {
        let url_ = this.baseUrl + "/parameter-location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseParameterLocationControllerParameterLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseParameterLocationControllerParameterLocation(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocation>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocation>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseParameterLocationControllerParameterLocation(response: HttpResponseBase): Observable<ParameterLocation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterLocation.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocation>(<any>null);
    }

    /**
     * Delete one ParameterLocation
     * @return Delete one base response
     */
    deleteOneBaseParameterLocationControllerParameterLocation(id: number): Observable<void> {
        let url_ = this.baseUrl + "/parameter-location/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseParameterLocationControllerParameterLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseParameterLocationControllerParameterLocation(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseParameterLocationControllerParameterLocation(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many ParameterLocation
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseParameterLocationControllerParameterLocation(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyParameterLocationResponseDto> {
        let url_ = this.baseUrl + "/parameter-location?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseParameterLocationControllerParameterLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseParameterLocationControllerParameterLocation(<any>response_);
                } catch (e) {
                    return <Observable<GetManyParameterLocationResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyParameterLocationResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseParameterLocationControllerParameterLocation(response: HttpResponseBase): Observable<GetManyParameterLocationResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyParameterLocationResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyParameterLocationResponseDto>(<any>null);
    }

    /**
     * Create one ParameterLocation
     * @return Get create one base response
     */
    createOneBaseParameterLocationControllerParameterLocation(body: ParameterLocation): Observable<ParameterLocation> {
        let url_ = this.baseUrl + "/parameter-location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseParameterLocationControllerParameterLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseParameterLocationControllerParameterLocation(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocation>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocation>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseParameterLocationControllerParameterLocation(response: HttpResponseBase): Observable<ParameterLocation> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ParameterLocation.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocation>(<any>null);
    }

    /**
     * Create many ParameterLocation
     * @return Get create many base response
     */
    createManyBaseParameterLocationControllerParameterLocation(body: CreateManyParameterLocationDto): Observable<ParameterLocation[]> {
        let url_ = this.baseUrl + "/parameter-location/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseParameterLocationControllerParameterLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseParameterLocationControllerParameterLocation(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocation[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseParameterLocationControllerParameterLocation(response: HttpResponseBase): Observable<ParameterLocation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ParameterLocation.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocation[]>(<any>null);
    }

    /**
     * Update one ParameterLocationData
     * @return Response
     */
    updateOneBaseParameterLocationDataControllerParameterLocationData(id: number, body: ParameterLocationData): Observable<ParameterLocationData> {
        let url_ = this.baseUrl + "/parameter-location-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseParameterLocationDataControllerParameterLocationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseParameterLocationDataControllerParameterLocationData(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocationData>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocationData>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseParameterLocationDataControllerParameterLocationData(response: HttpResponseBase): Observable<ParameterLocationData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterLocationData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocationData>(<any>null);
    }

    /**
     * Retrieve one ParameterLocationData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseParameterLocationDataControllerParameterLocationData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ParameterLocationData> {
        let url_ = this.baseUrl + "/parameter-location-data/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseParameterLocationDataControllerParameterLocationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseParameterLocationDataControllerParameterLocationData(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocationData>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocationData>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseParameterLocationDataControllerParameterLocationData(response: HttpResponseBase): Observable<ParameterLocationData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterLocationData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocationData>(<any>null);
    }

    /**
     * Replace one ParameterLocationData
     * @return Response
     */
    replaceOneBaseParameterLocationDataControllerParameterLocationData(id: number, body: ParameterLocationData): Observable<ParameterLocationData> {
        let url_ = this.baseUrl + "/parameter-location-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseParameterLocationDataControllerParameterLocationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseParameterLocationDataControllerParameterLocationData(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocationData>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocationData>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseParameterLocationDataControllerParameterLocationData(response: HttpResponseBase): Observable<ParameterLocationData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ParameterLocationData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocationData>(<any>null);
    }

    /**
     * Delete one ParameterLocationData
     * @return Delete one base response
     */
    deleteOneBaseParameterLocationDataControllerParameterLocationData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/parameter-location-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseParameterLocationDataControllerParameterLocationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseParameterLocationDataControllerParameterLocationData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseParameterLocationDataControllerParameterLocationData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create one ParameterLocationData
     * @return Get create one base response
     */
    createOneBaseParameterLocationDataControllerParameterLocationData(body: ParameterLocationData): Observable<ParameterLocationData> {
        let url_ = this.baseUrl + "/parameter-location-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseParameterLocationDataControllerParameterLocationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseParameterLocationDataControllerParameterLocationData(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocationData>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocationData>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseParameterLocationDataControllerParameterLocationData(response: HttpResponseBase): Observable<ParameterLocationData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ParameterLocationData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocationData>(<any>null);
    }

    /**
     * Retrieve many ParameterLocationData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseParameterLocationDataControllerParameterLocationData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyParameterLocationDataResponseDto> {
        let url_ = this.baseUrl + "/parameter-location-data?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseParameterLocationDataControllerParameterLocationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseParameterLocationDataControllerParameterLocationData(<any>response_);
                } catch (e) {
                    return <Observable<GetManyParameterLocationDataResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyParameterLocationDataResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseParameterLocationDataControllerParameterLocationData(response: HttpResponseBase): Observable<GetManyParameterLocationDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyParameterLocationDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyParameterLocationDataResponseDto>(<any>null);
    }

    /**
     * Create many ParameterLocationData
     * @return Get create many base response
     */
    createManyBaseParameterLocationDataControllerParameterLocationData(body: CreateManyParameterLocationDataDto): Observable<ParameterLocationData[]> {
        let url_ = this.baseUrl + "/parameter-location-data/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseParameterLocationDataControllerParameterLocationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseParameterLocationDataControllerParameterLocationData(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocationData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocationData[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseParameterLocationDataControllerParameterLocationData(response: HttpResponseBase): Observable<ParameterLocationData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ParameterLocationData.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocationData[]>(<any>null);
    }

    /**
     * Retrieve one DataRequestStatusHistory
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<DataRequestStatusHistory> {
        let url_ = this.baseUrl + "/datarequest-status-history/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(<any>response_);
                } catch (e) {
                    return <Observable<DataRequestStatusHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataRequestStatusHistory>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response: HttpResponseBase): Observable<DataRequestStatusHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataRequestStatusHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataRequestStatusHistory>(<any>null);
    }

    /**
     * Update one DataRequestStatusHistory
     * @return Response
     */
    updateOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(id: number, body: DataRequestStatusHistory): Observable<DataRequestStatusHistory> {
        let url_ = this.baseUrl + "/datarequest-status-history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(<any>response_);
                } catch (e) {
                    return <Observable<DataRequestStatusHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataRequestStatusHistory>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response: HttpResponseBase): Observable<DataRequestStatusHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataRequestStatusHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataRequestStatusHistory>(<any>null);
    }

    /**
     * Replace one DataRequestStatusHistory
     * @return Response
     */
    replaceOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(id: number, body: DataRequestStatusHistory): Observable<DataRequestStatusHistory> {
        let url_ = this.baseUrl + "/datarequest-status-history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(<any>response_);
                } catch (e) {
                    return <Observable<DataRequestStatusHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataRequestStatusHistory>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response: HttpResponseBase): Observable<DataRequestStatusHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataRequestStatusHistory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataRequestStatusHistory>(<any>null);
    }

    /**
     * Delete one DataRequestStatusHistory
     * @return Delete one base response
     */
    deleteOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(id: number): Observable<void> {
        let url_ = this.baseUrl + "/datarequest-status-history/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many DataRequestStatusHistory
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyDataRequestStatusHistoryResponseDto> {
        let url_ = this.baseUrl + "/datarequest-status-history?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(<any>response_);
                } catch (e) {
                    return <Observable<GetManyDataRequestStatusHistoryResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyDataRequestStatusHistoryResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response: HttpResponseBase): Observable<GetManyDataRequestStatusHistoryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyDataRequestStatusHistoryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyDataRequestStatusHistoryResponseDto>(<any>null);
    }

    /**
     * Create one DataRequestStatusHistory
     * @return Get create one base response
     */
    createOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(body: DataRequestStatusHistory): Observable<DataRequestStatusHistory> {
        let url_ = this.baseUrl + "/datarequest-status-history";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(<any>response_);
                } catch (e) {
                    return <Observable<DataRequestStatusHistory>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataRequestStatusHistory>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response: HttpResponseBase): Observable<DataRequestStatusHistory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = DataRequestStatusHistory.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataRequestStatusHistory>(<any>null);
    }

    /**
     * Create many DataRequestStatusHistory
     * @return Get create many base response
     */
    createManyBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(body: CreateManyDataRequestStatusHistoryDto): Observable<DataRequestStatusHistory[]> {
        let url_ = this.baseUrl + "/datarequest-status-history/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(<any>response_);
                } catch (e) {
                    return <Observable<DataRequestStatusHistory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataRequestStatusHistory[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseDatarequestStatusHistoryControllerDataRequestStatusHistory(response: HttpResponseBase): Observable<DataRequestStatusHistory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(DataRequestStatusHistory.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataRequestStatusHistory[]>(<any>null);
    }

    /**
     * Retrieve one ShoppingCart
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseShoppingCartControllerShoppingCart(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ShoppingCart> {
        let url_ = this.baseUrl + "/shopping-cart/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseShoppingCartControllerShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseShoppingCartControllerShoppingCart(<any>response_);
                } catch (e) {
                    return <Observable<ShoppingCart>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShoppingCart>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseShoppingCartControllerShoppingCart(response: HttpResponseBase): Observable<ShoppingCart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShoppingCart>(<any>null);
    }

    /**
     * Update one ShoppingCart
     * @return Response
     */
    updateOneBaseShoppingCartControllerShoppingCart(id: number, body: ShoppingCart): Observable<ShoppingCart> {
        let url_ = this.baseUrl + "/shopping-cart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseShoppingCartControllerShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseShoppingCartControllerShoppingCart(<any>response_);
                } catch (e) {
                    return <Observable<ShoppingCart>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShoppingCart>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseShoppingCartControllerShoppingCart(response: HttpResponseBase): Observable<ShoppingCart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShoppingCart>(<any>null);
    }

    /**
     * Replace one ShoppingCart
     * @return Response
     */
    replaceOneBaseShoppingCartControllerShoppingCart(id: number, body: ShoppingCart): Observable<ShoppingCart> {
        let url_ = this.baseUrl + "/shopping-cart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseShoppingCartControllerShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseShoppingCartControllerShoppingCart(<any>response_);
                } catch (e) {
                    return <Observable<ShoppingCart>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShoppingCart>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseShoppingCartControllerShoppingCart(response: HttpResponseBase): Observable<ShoppingCart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCart.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShoppingCart>(<any>null);
    }

    /**
     * Delete one ShoppingCart
     * @return Delete one base response
     */
    deleteOneBaseShoppingCartControllerShoppingCart(id: number): Observable<void> {
        let url_ = this.baseUrl + "/shopping-cart/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseShoppingCartControllerShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseShoppingCartControllerShoppingCart(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseShoppingCartControllerShoppingCart(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many ShoppingCart
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseShoppingCartControllerShoppingCart(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyShoppingCartResponseDto> {
        let url_ = this.baseUrl + "/shopping-cart?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseShoppingCartControllerShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseShoppingCartControllerShoppingCart(<any>response_);
                } catch (e) {
                    return <Observable<GetManyShoppingCartResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyShoppingCartResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseShoppingCartControllerShoppingCart(response: HttpResponseBase): Observable<GetManyShoppingCartResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyShoppingCartResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyShoppingCartResponseDto>(<any>null);
    }

    /**
     * Create one ShoppingCart
     * @return Get create one base response
     */
    createOneBaseShoppingCartControllerShoppingCart(body: ShoppingCart): Observable<ShoppingCart> {
        let url_ = this.baseUrl + "/shopping-cart";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseShoppingCartControllerShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseShoppingCartControllerShoppingCart(<any>response_);
                } catch (e) {
                    return <Observable<ShoppingCart>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShoppingCart>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseShoppingCartControllerShoppingCart(response: HttpResponseBase): Observable<ShoppingCart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ShoppingCart.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShoppingCart>(<any>null);
    }

    /**
     * Create many ShoppingCart
     * @return Get create many base response
     */
    createManyBaseShoppingCartControllerShoppingCart(body: CreateManyShoppingCartDto): Observable<ShoppingCart[]> {
        let url_ = this.baseUrl + "/shopping-cart/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseShoppingCartControllerShoppingCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseShoppingCartControllerShoppingCart(<any>response_);
                } catch (e) {
                    return <Observable<ShoppingCart[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShoppingCart[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseShoppingCartControllerShoppingCart(response: HttpResponseBase): Observable<ShoppingCart[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ShoppingCart.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShoppingCart[]>(<any>null);
    }

    /**
     * Retrieve one ProjectProgramme
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     */
    getOneBaseProjectProgramControllerProjectProgramme(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProjectProgramme> {
        let url_ = this.baseUrl + "/project-program/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectProgramControllerProjectProgramme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectProgramControllerProjectProgramme(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramme>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramme>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseProjectProgramControllerProjectProgramme(response: HttpResponseBase): Observable<ProjectProgramme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectProgramme.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramme>(<any>null);
    }

    /**
     * Delete one ProjectProgramme
     */
    deleteOneBaseProjectProgramControllerProjectProgramme(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project-program/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectProgramControllerProjectProgramme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectProgramControllerProjectProgramme(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseProjectProgramControllerProjectProgramme(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Update one ProjectProgramme
     * @return Response
     */
    updateOneBaseProjectProgramControllerProjectProgramme(id: number, body: ProjectProgramme): Observable<ProjectProgramme> {
        let url_ = this.baseUrl + "/project-program/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectProgramControllerProjectProgramme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectProgramControllerProjectProgramme(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramme>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramme>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseProjectProgramControllerProjectProgramme(response: HttpResponseBase): Observable<ProjectProgramme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectProgramme.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramme>(<any>null);
    }

    /**
     * Replace one ProjectProgramme
     * @return Response
     */
    replaceOneBaseProjectProgramControllerProjectProgramme(id: number, body: ProjectProgramme): Observable<ProjectProgramme> {
        let url_ = this.baseUrl + "/project-program/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectProgramControllerProjectProgramme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectProgramControllerProjectProgramme(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramme>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramme>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseProjectProgramControllerProjectProgramme(response: HttpResponseBase): Observable<ProjectProgramme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectProgramme.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramme>(<any>null);
    }

    /**
     * Retrieve many ProjectProgramme
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     */
    getManyBaseProjectProgramControllerProjectProgramme(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<any> {
        let url_ = this.baseUrl + "/project-program?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectProgramControllerProjectProgramme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectProgramControllerProjectProgramme(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseProjectProgramControllerProjectProgramme(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Create one ProjectProgramme
     * @return Get create one base response
     */
    createOneBaseProjectProgramControllerProjectProgramme(body: ProjectProgramme): Observable<ProjectProgramme> {
        let url_ = this.baseUrl + "/project-program";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectProgramControllerProjectProgramme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectProgramControllerProjectProgramme(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramme>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramme>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseProjectProgramControllerProjectProgramme(response: HttpResponseBase): Observable<ProjectProgramme> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectProgramme.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramme>(<any>null);
    }

    /**
     * Create many ProjectProgramme
     * @return Get create many base response
     */
    createManyBaseProjectProgramControllerProjectProgramme(body: CreateManyProjectProgrammeDto): Observable<ProjectProgramme[]> {
        let url_ = this.baseUrl + "/project-program/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectProgramControllerProjectProgramme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectProgramControllerProjectProgramme(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramme[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramme[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseProjectProgramControllerProjectProgramme(response: HttpResponseBase): Observable<ProjectProgramme[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectProgramme.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramme[]>(<any>null);
    }

    /**
     * Create one ProjectFundingDetail
     */
    createOneBaseProjectFundingDetailControllerProjectFundingDetail(body: ProjectFundingDetail): Observable<ProjectFundingDetail> {
        let url_ = this.baseUrl + "/project-funding-detail";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectFundingDetailControllerProjectFundingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectFundingDetailControllerProjectFundingDetail(<any>response_);
                } catch (e) {
                    return <Observable<ProjectFundingDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectFundingDetail>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseProjectFundingDetailControllerProjectFundingDetail(response: HttpResponseBase): Observable<ProjectFundingDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectFundingDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectFundingDetail.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectFundingDetail>(<any>null);
    }

    /**
     * Retrieve many ProjectFundingDetail
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectFundingDetailControllerProjectFundingDetail(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectFundingDetailResponseDto> {
        let url_ = this.baseUrl + "/project-funding-detail?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectFundingDetailControllerProjectFundingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectFundingDetailControllerProjectFundingDetail(<any>response_);
                } catch (e) {
                    return <Observable<GetManyProjectFundingDetailResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyProjectFundingDetailResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseProjectFundingDetailControllerProjectFundingDetail(response: HttpResponseBase): Observable<GetManyProjectFundingDetailResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectFundingDetailResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyProjectFundingDetailResponseDto>(<any>null);
    }

    /**
     * Update one ProjectFundingDetail
     */
    updateOneBaseProjectFundingDetailControllerProjectFundingDetail(id: number, body: ProjectFundingDetail): Observable<ProjectFundingDetail> {
        let url_ = this.baseUrl + "/project-funding-detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectFundingDetailControllerProjectFundingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectFundingDetailControllerProjectFundingDetail(<any>response_);
                } catch (e) {
                    return <Observable<ProjectFundingDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectFundingDetail>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseProjectFundingDetailControllerProjectFundingDetail(response: HttpResponseBase): Observable<ProjectFundingDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectFundingDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectFundingDetail>(<any>null);
    }

    /**
     * Retrieve one ProjectFundingDetail
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectFundingDetailControllerProjectFundingDetail(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProjectFundingDetail> {
        let url_ = this.baseUrl + "/project-funding-detail/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectFundingDetailControllerProjectFundingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectFundingDetailControllerProjectFundingDetail(<any>response_);
                } catch (e) {
                    return <Observable<ProjectFundingDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectFundingDetail>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseProjectFundingDetailControllerProjectFundingDetail(response: HttpResponseBase): Observable<ProjectFundingDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectFundingDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectFundingDetail>(<any>null);
    }

    /**
     * Replace one ProjectFundingDetail
     * @return Response
     */
    replaceOneBaseProjectFundingDetailControllerProjectFundingDetail(id: number, body: ProjectFundingDetail): Observable<ProjectFundingDetail> {
        let url_ = this.baseUrl + "/project-funding-detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectFundingDetailControllerProjectFundingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectFundingDetailControllerProjectFundingDetail(<any>response_);
                } catch (e) {
                    return <Observable<ProjectFundingDetail>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectFundingDetail>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseProjectFundingDetailControllerProjectFundingDetail(response: HttpResponseBase): Observable<ProjectFundingDetail> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectFundingDetail.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectFundingDetail>(<any>null);
    }

    /**
     * Delete one ProjectFundingDetail
     * @return Delete one base response
     */
    deleteOneBaseProjectFundingDetailControllerProjectFundingDetail(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project-funding-detail/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectFundingDetailControllerProjectFundingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectFundingDetailControllerProjectFundingDetail(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseProjectFundingDetailControllerProjectFundingDetail(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Create many ProjectFundingDetail
     * @return Get create many base response
     */
    createManyBaseProjectFundingDetailControllerProjectFundingDetail(body: CreateManyProjectFundingDetailDto): Observable<ProjectFundingDetail[]> {
        let url_ = this.baseUrl + "/project-funding-detail/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectFundingDetailControllerProjectFundingDetail(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectFundingDetailControllerProjectFundingDetail(<any>response_);
                } catch (e) {
                    return <Observable<ProjectFundingDetail[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectFundingDetail[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseProjectFundingDetailControllerProjectFundingDetail(response: HttpResponseBase): Observable<ProjectFundingDetail[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectFundingDetail.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectFundingDetail[]>(<any>null);
    }

    /**
     * Retrieve many Policy
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     */
    getManyBasePolicyControllerPolicy(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<any> {
        let url_ = this.baseUrl + "/policy?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBasePolicyControllerPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBasePolicyControllerPolicy(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBasePolicyControllerPolicy(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    /**
     * Create one Policy
     * @return Get create one base response
     */
    createOneBasePolicyControllerPolicy(body: Policy): Observable<Policy> {
        let url_ = this.baseUrl + "/policy";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBasePolicyControllerPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBasePolicyControllerPolicy(<any>response_);
                } catch (e) {
                    return <Observable<Policy>><any>_observableThrow(e);
                }
            } else
                return <Observable<Policy>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBasePolicyControllerPolicy(response: HttpResponseBase): Observable<Policy> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Policy.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Policy>(<any>null);
    }

    /**
     * Retrieve one Policy
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     */
    getOneBasePolicyControllerPolicy(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Policy> {
        let url_ = this.baseUrl + "/policy/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBasePolicyControllerPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBasePolicyControllerPolicy(<any>response_);
                } catch (e) {
                    return <Observable<Policy>><any>_observableThrow(e);
                }
            } else
                return <Observable<Policy>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBasePolicyControllerPolicy(response: HttpResponseBase): Observable<Policy> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Policy.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Policy>(<any>null);
    }

    /**
     * Delete one Policy
     */
    deleteOneBasePolicyControllerPolicy(id: number): Observable<void> {
        let url_ = this.baseUrl + "/policy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBasePolicyControllerPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBasePolicyControllerPolicy(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBasePolicyControllerPolicy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Update one Policy
     */
    updateOneBasePolicyControllerPolicy(id: number, body: Policy): Observable<void> {
        let url_ = this.baseUrl + "/policy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBasePolicyControllerPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBasePolicyControllerPolicy(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBasePolicyControllerPolicy(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Replace one Policy
     * @return Response
     */
    replaceOneBasePolicyControllerPolicy(id: number, body: Policy): Observable<Policy> {
        let url_ = this.baseUrl + "/policy/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBasePolicyControllerPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBasePolicyControllerPolicy(<any>response_);
                } catch (e) {
                    return <Observable<Policy>><any>_observableThrow(e);
                }
            } else
                return <Observable<Policy>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBasePolicyControllerPolicy(response: HttpResponseBase): Observable<Policy> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Policy.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Policy>(<any>null);
    }

    /**
     * Create many Policy
     * @return Get create many base response
     */
    createManyBasePolicyControllerPolicy(body: CreateManyPolicyDto): Observable<Policy[]> {
        let url_ = this.baseUrl + "/policy/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBasePolicyControllerPolicy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBasePolicyControllerPolicy(<any>response_);
                } catch (e) {
                    return <Observable<Policy[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Policy[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBasePolicyControllerPolicy(response: HttpResponseBase): Observable<Policy[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Policy.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Policy[]>(<any>null);
    }

    /**
     * Retrieve one ProjectStatus
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectStatusControllerProjectStatus(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProjectStatus> {
        let url_ = this.baseUrl + "/project-status/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectStatusControllerProjectStatus(<any>response_);
                } catch (e) {
                    return <Observable<ProjectStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<ProjectStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectStatus>(<any>null);
    }

    /**
     * Update one ProjectStatus
     * @return Response
     */
    updateOneBaseProjectStatusControllerProjectStatus(id: number, body: ProjectStatus): Observable<ProjectStatus> {
        let url_ = this.baseUrl + "/project-status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectStatusControllerProjectStatus(<any>response_);
                } catch (e) {
                    return <Observable<ProjectStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectStatus>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<ProjectStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectStatus>(<any>null);
    }

    /**
     * Replace one ProjectStatus
     * @return Response
     */
    replaceOneBaseProjectStatusControllerProjectStatus(id: number, body: ProjectStatus): Observable<ProjectStatus> {
        let url_ = this.baseUrl + "/project-status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectStatusControllerProjectStatus(<any>response_);
                } catch (e) {
                    return <Observable<ProjectStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectStatus>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<ProjectStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectStatus>(<any>null);
    }

    /**
     * Delete one ProjectStatus
     * @return Delete one base response
     */
    deleteOneBaseProjectStatusControllerProjectStatus(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project-status/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectStatusControllerProjectStatus(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many ProjectStatus
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectStatusControllerProjectStatus(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectStatusResponseDto> {
        let url_ = this.baseUrl + "/project-status?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectStatusControllerProjectStatus(<any>response_);
                } catch (e) {
                    return <Observable<GetManyProjectStatusResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyProjectStatusResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<GetManyProjectStatusResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectStatusResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyProjectStatusResponseDto>(<any>null);
    }

    /**
     * Create one ProjectStatus
     * @return Get create one base response
     */
    createOneBaseProjectStatusControllerProjectStatus(body: ProjectStatus): Observable<ProjectStatus> {
        let url_ = this.baseUrl + "/project-status";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectStatusControllerProjectStatus(<any>response_);
                } catch (e) {
                    return <Observable<ProjectStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectStatus>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<ProjectStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectStatus.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectStatus>(<any>null);
    }

    /**
     * Create many ProjectStatus
     * @return Get create many base response
     */
    createManyBaseProjectStatusControllerProjectStatus(body: CreateManyProjectStatusDto): Observable<ProjectStatus[]> {
        let url_ = this.baseUrl + "/project-status/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectStatusControllerProjectStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectStatusControllerProjectStatus(<any>response_);
                } catch (e) {
                    return <Observable<ProjectStatus[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectStatus[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseProjectStatusControllerProjectStatus(response: HttpResponseBase): Observable<ProjectStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectStatus.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectStatus[]>(<any>null);
    }

    /**
     * Retrieve one Documents
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseDocumentControllerDocuments(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Documents>(<any>null);
    }

    /**
     * Update one Documents
     * @return Response
     */
    updateOneBaseDocumentControllerDocuments(id: number, body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Documents>(<any>null);
    }

    /**
     * Replace one Documents
     * @return Response
     */
    replaceOneBaseDocumentControllerDocuments(id: number, body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = Documents.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Documents>(<any>null);
    }

    /**
     * Delete one Documents
     * @return Delete one base response
     */
    deleteOneBaseDocumentControllerDocuments(id: number): Observable<void> {
        let url_ = this.baseUrl + "/document/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many Documents
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseDocumentControllerDocuments(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyDocumentsResponseDto> {
        let url_ = this.baseUrl + "/document?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<GetManyDocumentsResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyDocumentsResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<GetManyDocumentsResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyDocumentsResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyDocumentsResponseDto>(<any>null);
    }

    /**
     * Create one Documents
     * @return Get create one base response
     */
    createOneBaseDocumentControllerDocuments(body: Documents): Observable<Documents> {
        let url_ = this.baseUrl + "/document";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Documents.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Documents>(<any>null);
    }

    /**
     * Create many Documents
     * @return Get create many base response
     */
    createManyBaseDocumentControllerDocuments(body: CreateManyDocumentsDto): Observable<Documents[]> {
        let url_ = this.baseUrl + "/document/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseDocumentControllerDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseDocumentControllerDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseDocumentControllerDocuments(response: HttpResponseBase): Observable<Documents[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(Documents.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Documents[]>(<any>null);
    }

    /**
     * Create many ProjectProgramData
     */
    createManyBaseProjectProgramDataControllerProjectProgramData(body: CreateManyProjectProgramDataDto): Observable<ProjectProgramData[]> {
        let url_ = this.baseUrl + "/project-program-data/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseProjectProgramDataControllerProjectProgramData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseProjectProgramDataControllerProjectProgramData(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramData[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseProjectProgramDataControllerProjectProgramData(response: HttpResponseBase): Observable<ProjectProgramData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProjectProgramData.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ProjectProgramData.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramData[]>(<any>null);
    }

    /**
     * Retrieve one ProjectProgramData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseProjectProgramDataControllerProjectProgramData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<ProjectProgramData> {
        let url_ = this.baseUrl + "/project-program-data/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseProjectProgramDataControllerProjectProgramData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseProjectProgramDataControllerProjectProgramData(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramData>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramData>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseProjectProgramDataControllerProjectProgramData(response: HttpResponseBase): Observable<ProjectProgramData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectProgramData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramData>(<any>null);
    }

    /**
     * Update one ProjectProgramData
     * @return Response
     */
    updateOneBaseProjectProgramDataControllerProjectProgramData(id: number, body: ProjectProgramData): Observable<ProjectProgramData> {
        let url_ = this.baseUrl + "/project-program-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseProjectProgramDataControllerProjectProgramData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseProjectProgramDataControllerProjectProgramData(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramData>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramData>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseProjectProgramDataControllerProjectProgramData(response: HttpResponseBase): Observable<ProjectProgramData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectProgramData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramData>(<any>null);
    }

    /**
     * Replace one ProjectProgramData
     * @return Response
     */
    replaceOneBaseProjectProgramDataControllerProjectProgramData(id: number, body: ProjectProgramData): Observable<ProjectProgramData> {
        let url_ = this.baseUrl + "/project-program-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseProjectProgramDataControllerProjectProgramData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseProjectProgramDataControllerProjectProgramData(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramData>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramData>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseProjectProgramDataControllerProjectProgramData(response: HttpResponseBase): Observable<ProjectProgramData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ProjectProgramData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramData>(<any>null);
    }

    /**
     * Delete one ProjectProgramData
     * @return Delete one base response
     */
    deleteOneBaseProjectProgramDataControllerProjectProgramData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/project-program-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseProjectProgramDataControllerProjectProgramData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseProjectProgramDataControllerProjectProgramData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseProjectProgramDataControllerProjectProgramData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many ProjectProgramData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseProjectProgramDataControllerProjectProgramData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyProjectProgramDataResponseDto> {
        let url_ = this.baseUrl + "/project-program-data?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseProjectProgramDataControllerProjectProgramData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseProjectProgramDataControllerProjectProgramData(<any>response_);
                } catch (e) {
                    return <Observable<GetManyProjectProgramDataResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyProjectProgramDataResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseProjectProgramDataControllerProjectProgramData(response: HttpResponseBase): Observable<GetManyProjectProgramDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyProjectProgramDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyProjectProgramDataResponseDto>(<any>null);
    }

    /**
     * Create one ProjectProgramData
     * @return Get create one base response
     */
    createOneBaseProjectProgramDataControllerProjectProgramData(body: ProjectProgramData): Observable<ProjectProgramData> {
        let url_ = this.baseUrl + "/project-program-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseProjectProgramDataControllerProjectProgramData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseProjectProgramDataControllerProjectProgramData(<any>response_);
                } catch (e) {
                    return <Observable<ProjectProgramData>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectProgramData>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseProjectProgramDataControllerProjectProgramData(response: HttpResponseBase): Observable<ProjectProgramData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ProjectProgramData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectProgramData>(<any>null);
    }

    /**
     * Retrieve one PolicyData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBasePolicyDataControllerPolicyData(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<PolicyData> {
        let url_ = this.baseUrl + "/policy-data/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBasePolicyDataControllerPolicyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBasePolicyDataControllerPolicyData(<any>response_);
                } catch (e) {
                    return <Observable<PolicyData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PolicyData>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBasePolicyDataControllerPolicyData(response: HttpResponseBase): Observable<PolicyData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PolicyData>(<any>null);
    }

    /**
     * Update one PolicyData
     * @return Response
     */
    updateOneBasePolicyDataControllerPolicyData(id: number, body: PolicyData): Observable<PolicyData> {
        let url_ = this.baseUrl + "/policy-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBasePolicyDataControllerPolicyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBasePolicyDataControllerPolicyData(<any>response_);
                } catch (e) {
                    return <Observable<PolicyData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PolicyData>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBasePolicyDataControllerPolicyData(response: HttpResponseBase): Observable<PolicyData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PolicyData>(<any>null);
    }

    /**
     * Replace one PolicyData
     * @return Response
     */
    replaceOneBasePolicyDataControllerPolicyData(id: number, body: PolicyData): Observable<PolicyData> {
        let url_ = this.baseUrl + "/policy-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBasePolicyDataControllerPolicyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBasePolicyDataControllerPolicyData(<any>response_);
                } catch (e) {
                    return <Observable<PolicyData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PolicyData>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBasePolicyDataControllerPolicyData(response: HttpResponseBase): Observable<PolicyData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PolicyData.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PolicyData>(<any>null);
    }

    /**
     * Delete one PolicyData
     * @return Delete one base response
     */
    deleteOneBasePolicyDataControllerPolicyData(id: number): Observable<void> {
        let url_ = this.baseUrl + "/policy-data/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBasePolicyDataControllerPolicyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBasePolicyDataControllerPolicyData(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBasePolicyDataControllerPolicyData(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many PolicyData
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBasePolicyDataControllerPolicyData(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyPolicyDataResponseDto> {
        let url_ = this.baseUrl + "/policy-data?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBasePolicyDataControllerPolicyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBasePolicyDataControllerPolicyData(<any>response_);
                } catch (e) {
                    return <Observable<GetManyPolicyDataResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyPolicyDataResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBasePolicyDataControllerPolicyData(response: HttpResponseBase): Observable<GetManyPolicyDataResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyPolicyDataResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyPolicyDataResponseDto>(<any>null);
    }

    /**
     * Create one PolicyData
     * @return Get create one base response
     */
    createOneBasePolicyDataControllerPolicyData(body: PolicyData): Observable<PolicyData> {
        let url_ = this.baseUrl + "/policy-data";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBasePolicyDataControllerPolicyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBasePolicyDataControllerPolicyData(<any>response_);
                } catch (e) {
                    return <Observable<PolicyData>><any>_observableThrow(e);
                }
            } else
                return <Observable<PolicyData>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBasePolicyDataControllerPolicyData(response: HttpResponseBase): Observable<PolicyData> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = PolicyData.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PolicyData>(<any>null);
    }

    /**
     * Create many PolicyData
     * @return Get create many base response
     */
    createManyBasePolicyDataControllerPolicyData(body: CreateManyPolicyDataDto): Observable<PolicyData[]> {
        let url_ = this.baseUrl + "/policy-data/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBasePolicyDataControllerPolicyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBasePolicyDataControllerPolicyData(<any>response_);
                } catch (e) {
                    return <Observable<PolicyData[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<PolicyData[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBasePolicyDataControllerPolicyData(response: HttpResponseBase): Observable<PolicyData[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(PolicyData.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PolicyData[]>(<any>null);
    }

    /**
     * Retrieve one UserDataUsageCategory
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get one base response
     */
    getOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(id: number, fields: string[] | undefined, join: string[] | undefined, cache: number | undefined): Observable<UserDataUsageCategory> {
        let url_ = this.baseUrl + "/user-data-usage-category/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(<any>response_);
                } catch (e) {
                    return <Observable<UserDataUsageCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDataUsageCategory>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(response: HttpResponseBase): Observable<UserDataUsageCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDataUsageCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDataUsageCategory>(<any>null);
    }

    /**
     * Update one UserDataUsageCategory
     * @return Response
     */
    updateOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(id: number, body: UserDataUsageCategory): Observable<UserDataUsageCategory> {
        let url_ = this.baseUrl + "/user-data-usage-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("patch", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(<any>response_);
                } catch (e) {
                    return <Observable<UserDataUsageCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDataUsageCategory>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(response: HttpResponseBase): Observable<UserDataUsageCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDataUsageCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDataUsageCategory>(<any>null);
    }

    /**
     * Replace one UserDataUsageCategory
     * @return Response
     */
    replaceOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(id: number, body: UserDataUsageCategory): Observable<UserDataUsageCategory> {
        let url_ = this.baseUrl + "/user-data-usage-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processReplaceOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processReplaceOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(<any>response_);
                } catch (e) {
                    return <Observable<UserDataUsageCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDataUsageCategory>><any>_observableThrow(response_);
        }));
    }

    protected processReplaceOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(response: HttpResponseBase): Observable<UserDataUsageCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDataUsageCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDataUsageCategory>(<any>null);
    }

    /**
     * Delete one UserDataUsageCategory
     * @return Delete one base response
     */
    deleteOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(id: number): Observable<void> {
        let url_ = this.baseUrl + "/user-data-usage-category/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    /**
     * Retrieve many UserDataUsageCategory
     * @param fields (optional) Selects resource fields. <a href="https://github.com/nestjsx/crud/wiki/Requests#select" target="_blank">Docs</a>
     * @param s (optional) Adds search condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#search" target="_blank">Docs</a>
     * @param filter (optional) Adds filter condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#filter" target="_blank">Docs</a>
     * @param or (optional) Adds OR condition. <a href="https://github.com/nestjsx/crud/wiki/Requests#or" target="_blank">Docs</a>
     * @param sort (optional) Adds sort by field. <a href="https://github.com/nestjsx/crud/wiki/Requests#sort" target="_blank">Docs</a>
     * @param join (optional) Adds relational resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#join" target="_blank">Docs</a>
     * @param limit (optional) Limit amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#limit" target="_blank">Docs</a>
     * @param offset (optional) Offset amount of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#offset" target="_blank">Docs</a>
     * @param page (optional) Page portion of resources. <a href="https://github.com/nestjsx/crud/wiki/Requests#page" target="_blank">Docs</a>
     * @param cache (optional) Reset cache (if was enabled). <a href="https://github.com/nestjsx/crud/wiki/Requests#cache" target="_blank">Docs</a>
     * @return Get many base response
     */
    getManyBaseUserDataUsageCategoryControllerUserDataUsageCategory(fields: string[] | undefined, s: string | undefined, filter: string[] | undefined, or: string[] | undefined, sort: string[] | undefined, join: string[] | undefined, limit: number | undefined, offset: number | undefined, page: number | undefined, cache: number | undefined): Observable<GetManyUserDataUsageCategoryResponseDto> {
        let url_ = this.baseUrl + "/user-data-usage-category?";
        if (fields === null)
            throw new Error("The parameter 'fields' cannot be null.");
        else if (fields !== undefined)
            fields && fields.forEach(item => { url_ += "fields=" + encodeURIComponent("" + item) + "&"; });
        if (s === null)
            throw new Error("The parameter 's' cannot be null.");
        else if (s !== undefined)
            url_ += "s=" + encodeURIComponent("" + s) + "&";
        if (filter === null)
            throw new Error("The parameter 'filter' cannot be null.");
        else if (filter !== undefined)
            filter && filter.forEach(item => { url_ += "filter=" + encodeURIComponent("" + item) + "&"; });
        if (or === null)
            throw new Error("The parameter 'or' cannot be null.");
        else if (or !== undefined)
            or && or.forEach(item => { url_ += "or=" + encodeURIComponent("" + item) + "&"; });
        if (sort === null)
            throw new Error("The parameter 'sort' cannot be null.");
        else if (sort !== undefined)
            sort && sort.forEach(item => { url_ += "sort=" + encodeURIComponent("" + item) + "&"; });
        if (join === null)
            throw new Error("The parameter 'join' cannot be null.");
        else if (join !== undefined)
            join && join.forEach(item => { url_ += "join=" + encodeURIComponent("" + item) + "&"; });
        if (limit === null)
            throw new Error("The parameter 'limit' cannot be null.");
        else if (limit !== undefined)
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (offset === null)
            throw new Error("The parameter 'offset' cannot be null.");
        else if (offset !== undefined)
            url_ += "offset=" + encodeURIComponent("" + offset) + "&";
        if (page === null)
            throw new Error("The parameter 'page' cannot be null.");
        else if (page !== undefined)
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (cache === null)
            throw new Error("The parameter 'cache' cannot be null.");
        else if (cache !== undefined)
            url_ += "cache=" + encodeURIComponent("" + cache) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManyBaseUserDataUsageCategoryControllerUserDataUsageCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManyBaseUserDataUsageCategoryControllerUserDataUsageCategory(<any>response_);
                } catch (e) {
                    return <Observable<GetManyUserDataUsageCategoryResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<GetManyUserDataUsageCategoryResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetManyBaseUserDataUsageCategoryControllerUserDataUsageCategory(response: HttpResponseBase): Observable<GetManyUserDataUsageCategoryResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetManyUserDataUsageCategoryResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<GetManyUserDataUsageCategoryResponseDto>(<any>null);
    }

    /**
     * Create one UserDataUsageCategory
     * @return Get create one base response
     */
    createOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(body: UserDataUsageCategory): Observable<UserDataUsageCategory> {
        let url_ = this.baseUrl + "/user-data-usage-category";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(<any>response_);
                } catch (e) {
                    return <Observable<UserDataUsageCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDataUsageCategory>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOneBaseUserDataUsageCategoryControllerUserDataUsageCategory(response: HttpResponseBase): Observable<UserDataUsageCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = UserDataUsageCategory.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDataUsageCategory>(<any>null);
    }

    /**
     * Create many UserDataUsageCategory
     * @return Get create many base response
     */
    createManyBaseUserDataUsageCategoryControllerUserDataUsageCategory(body: CreateManyUserDataUsageCategoryDto): Observable<UserDataUsageCategory[]> {
        let url_ = this.baseUrl + "/user-data-usage-category/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateManyBaseUserDataUsageCategoryControllerUserDataUsageCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateManyBaseUserDataUsageCategoryControllerUserDataUsageCategory(<any>response_);
                } catch (e) {
                    return <Observable<UserDataUsageCategory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDataUsageCategory[]>><any>_observableThrow(response_);
        }));
    }

    protected processCreateManyBaseUserDataUsageCategoryControllerUserDataUsageCategory(response: HttpResponseBase): Observable<UserDataUsageCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(UserDataUsageCategory.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDataUsageCategory[]>(<any>null);
    }
}

@Injectable()
export class InstitutionControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getRequestSummary(institutionId: number): Observable<RequestSummary[]> {
        let url_ = this.baseUrl + "/institution/institution/getrequestsummary/{institutionId}";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined.");
        url_ = url_.replace("{institutionId}", encodeURIComponent("" + institutionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestSummary(<any>response_);
                } catch (e) {
                    return <Observable<RequestSummary[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestSummary[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestSummary(response: HttpResponseBase): Observable<RequestSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RequestSummary.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestSummary[]>(<any>null);
    }

    getRecentUpdateSummary(institutionId: number): Observable<RecentUpdateSummary[]> {
        let url_ = this.baseUrl + "/institution/institution/getrecentupdatesummary/{institutionId}";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined.");
        url_ = url_.replace("{institutionId}", encodeURIComponent("" + institutionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentUpdateSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentUpdateSummary(<any>response_);
                } catch (e) {
                    return <Observable<RecentUpdateSummary[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RecentUpdateSummary[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentUpdateSummary(response: HttpResponseBase): Observable<RecentUpdateSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RecentUpdateSummary.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RecentUpdateSummary[]>(<any>null);
    }

    getRecentAssignSummary(institutionId: number): Observable<RequestAssignSummary[]> {
        let url_ = this.baseUrl + "/institution/institution/getrecentassignsummary/{institutionId}";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined.");
        url_ = url_.replace("{institutionId}", encodeURIComponent("" + institutionId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRecentAssignSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRecentAssignSummary(<any>response_);
                } catch (e) {
                    return <Observable<RequestAssignSummary[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<RequestAssignSummary[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetRecentAssignSummary(response: HttpResponseBase): Observable<RequestAssignSummary[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(RequestAssignSummary.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<RequestAssignSummary[]>(<any>null);
    }
}

@Injectable()
export class MasterdataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getDataUsageCategory(): Observable<DataUsageCategory[]> {
        let url_ = this.baseUrl + "/masterdata/DataUsageCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataUsageCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataUsageCategory(<any>response_);
                } catch (e) {
                    return <Observable<DataUsageCategory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataUsageCategory[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataUsageCategory(response: HttpResponseBase): Observable<DataUsageCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataUsageCategory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataUsageCategory[]>(<any>null);
    }

    getAllClimateImpact(): Observable<ClimateImpact[]> {
        let url_ = this.baseUrl + "/masterdata/ClimateImpact";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllClimateImpact(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllClimateImpact(<any>response_);
                } catch (e) {
                    return <Observable<ClimateImpact[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateImpact[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllClimateImpact(response: HttpResponseBase): Observable<ClimateImpact[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ClimateImpact.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateImpact[]>(<any>null);
    }

    getAllDeadline(): Observable<Deadline[]> {
        let url_ = this.baseUrl + "/masterdata/Deadline";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDeadline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDeadline(<any>response_);
                } catch (e) {
                    return <Observable<Deadline[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Deadline[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDeadline(response: HttpResponseBase): Observable<Deadline[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Deadline.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Deadline[]>(<any>null);
    }

    getAllHierarchy(): Observable<Hierarchy[]> {
        let url_ = this.baseUrl + "/masterdata/Hierarchy";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllHierarchy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllHierarchy(<any>response_);
                } catch (e) {
                    return <Observable<Hierarchy[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Hierarchy[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllHierarchy(response: HttpResponseBase): Observable<Hierarchy[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Hierarchy.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Hierarchy[]>(<any>null);
    }

    getAllFrequncy(): Observable<Frequency[]> {
        let url_ = this.baseUrl + "/masterdata/Frequency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFrequncy(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFrequncy(<any>response_);
                } catch (e) {
                    return <Observable<Frequency[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Frequency[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFrequncy(response: HttpResponseBase): Observable<Frequency[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Frequency.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Frequency[]>(<any>null);
    }

    getAllDataRequsetStatus(): Observable<DataRequestStatus[]> {
        let url_ = this.baseUrl + "/masterdata/DataRequsetStatus";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDataRequsetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDataRequsetStatus(<any>response_);
                } catch (e) {
                    return <Observable<DataRequestStatus[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataRequestStatus[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDataRequsetStatus(response: HttpResponseBase): Observable<DataRequestStatus[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataRequestStatus.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataRequestStatus[]>(<any>null);
    }

    getDataRequsetStatus(id: number): Observable<DataRequestStatus> {
        let url_ = this.baseUrl + "/masterdata/DataRequsetStatus/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataRequsetStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataRequsetStatus(<any>response_);
                } catch (e) {
                    return <Observable<DataRequestStatus>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataRequestStatus>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataRequsetStatus(response: HttpResponseBase): Observable<DataRequestStatus> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = DataRequestStatus.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataRequestStatus>(<any>null);
    }

    getDataRequsetHistory(parameterLocationDataId: number): Observable<DataRequestStatusHistory[]> {
        let url_ = this.baseUrl + "/masterdata/getDataRequsetHistory/{parameterLocationDataId}";
        if (parameterLocationDataId === undefined || parameterLocationDataId === null)
            throw new Error("The parameter 'parameterLocationDataId' must be defined.");
        url_ = url_.replace("{parameterLocationDataId}", encodeURIComponent("" + parameterLocationDataId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataRequsetHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataRequsetHistory(<any>response_);
                } catch (e) {
                    return <Observable<DataRequestStatusHistory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DataRequestStatusHistory[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataRequsetHistory(response: HttpResponseBase): Observable<DataRequestStatusHistory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DataRequestStatusHistory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DataRequestStatusHistory[]>(<any>null);
    }

    getAllSubSectorbySector(sectorId: number): Observable<SubSector[]> {
        let url_ = this.baseUrl + "/masterdata/SubSector/{sectorId}";
        if (sectorId === undefined || sectorId === null)
            throw new Error("The parameter 'sectorId' must be defined.");
        url_ = url_.replace("{sectorId}", encodeURIComponent("" + sectorId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSubSectorbySector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSubSectorbySector(<any>response_);
                } catch (e) {
                    return <Observable<SubSector[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SubSector[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSubSectorbySector(response: HttpResponseBase): Observable<SubSector[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SubSector.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SubSector[]>(<any>null);
    }

    getAllFinancingScheme(): Observable<FinancingScheme[]> {
        let url_ = this.baseUrl + "/masterdata/FinancingScheme";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFinancingScheme(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFinancingScheme(<any>response_);
                } catch (e) {
                    return <Observable<FinancingScheme[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<FinancingScheme[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFinancingScheme(response: HttpResponseBase): Observable<FinancingScheme[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(FinancingScheme.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FinancingScheme[]>(<any>null);
    }

    getAllSDBenefit(): Observable<SDBenefit[]> {
        let url_ = this.baseUrl + "/masterdata/SDBenefit";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSDBenefit(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSDBenefit(<any>response_);
                } catch (e) {
                    return <Observable<SDBenefit[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<SDBenefit[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSDBenefit(response: HttpResponseBase): Observable<SDBenefit[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(SDBenefit.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<SDBenefit[]>(<any>null);
    }

    getAllCurrency(): Observable<Currency[]> {
        let url_ = this.baseUrl + "/masterdata/Currency";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllCurrency(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllCurrency(<any>response_);
                } catch (e) {
                    return <Observable<Currency[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Currency[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllCurrency(response: HttpResponseBase): Observable<Currency[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Currency.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Currency[]>(<any>null);
    }

    getAllSector(): Observable<Sector[]> {
        let url_ = this.baseUrl + "/masterdata/Sector";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSector(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSector(<any>response_);
                } catch (e) {
                    return <Observable<Sector[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sector[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSector(response: HttpResponseBase): Observable<Sector[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Sector.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sector[]>(<any>null);
    }

    getAllSectorByCCDataCatagary(ccdataId: number): Observable<Sector[]> {
        let url_ = this.baseUrl + "/masterdata/Sector/{ccdataId}";
        if (ccdataId === undefined || ccdataId === null)
            throw new Error("The parameter 'ccdataId' must be defined.");
        url_ = url_.replace("{ccdataId}", encodeURIComponent("" + ccdataId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllSectorByCCDataCatagary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllSectorByCCDataCatagary(<any>response_);
                } catch (e) {
                    return <Observable<Sector[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Sector[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllSectorByCCDataCatagary(response: HttpResponseBase): Observable<Sector[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Sector.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Sector[]>(<any>null);
    }

    getAllClimateChangeDataCategory(): Observable<ClimateChangeDataCategory[]> {
        let url_ = this.baseUrl + "/masterdata/ClimateChangeDataCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllClimateChangeDataCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllClimateChangeDataCategory(<any>response_);
                } catch (e) {
                    return <Observable<ClimateChangeDataCategory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ClimateChangeDataCategory[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllClimateChangeDataCategory(response: HttpResponseBase): Observable<ClimateChangeDataCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ClimateChangeDataCategory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ClimateChangeDataCategory[]>(<any>null);
    }

    getAllInstitutionCategory(): Observable<InstitutionCategory[]> {
        let url_ = this.baseUrl + "/masterdata/institution-category";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInstitutionCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInstitutionCategory(<any>response_);
                } catch (e) {
                    return <Observable<InstitutionCategory[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InstitutionCategory[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllInstitutionCategory(response: HttpResponseBase): Observable<InstitutionCategory[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InstitutionCategory.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstitutionCategory[]>(<any>null);
    }

    getAllInstitutionType(): Observable<InstitutionType[]> {
        let url_ = this.baseUrl + "/masterdata/institution-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllInstitutionType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllInstitutionType(<any>response_);
                } catch (e) {
                    return <Observable<InstitutionType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<InstitutionType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllInstitutionType(response: HttpResponseBase): Observable<InstitutionType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(InstitutionType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<InstitutionType[]>(<any>null);
    }

    getAllProvince(): Observable<Province[]> {
        let url_ = this.baseUrl + "/masterdata/province";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProvince(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProvince(<any>response_);
                } catch (e) {
                    return <Observable<Province[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Province[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProvince(response: HttpResponseBase): Observable<Province[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Province.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Province[]>(<any>null);
    }

    getAllProjectType(): Observable<ProjectType[]> {
        let url_ = this.baseUrl + "/masterdata/projectType";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllProjectType(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllProjectType(<any>response_);
                } catch (e) {
                    return <Observable<ProjectType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ProjectType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllProjectType(response: HttpResponseBase): Observable<ProjectType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ProjectType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ProjectType[]>(<any>null);
    }

    getAllDistricts(): Observable<District[]> {
        let url_ = this.baseUrl + "/masterdata/district";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDistricts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDistricts(<any>response_);
                } catch (e) {
                    return <Observable<District[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<District[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDistricts(response: HttpResponseBase): Observable<District[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(District.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<District[]>(<any>null);
    }

    getAllDistrictsByProvince(provinceId: number): Observable<District[]> {
        let url_ = this.baseUrl + "/masterdata/district/{provinceId}";
        if (provinceId === undefined || provinceId === null)
            throw new Error("The parameter 'provinceId' must be defined.");
        url_ = url_.replace("{provinceId}", encodeURIComponent("" + provinceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDistrictsByProvince(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDistrictsByProvince(<any>response_);
                } catch (e) {
                    return <Observable<District[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<District[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDistrictsByProvince(response: HttpResponseBase): Observable<District[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(District.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<District[]>(<any>null);
    }

    getAllDivisionalSecretariat(): Observable<DivisionalSecretariat[]> {
        let url_ = this.baseUrl + "/masterdata/divisional-secretariat";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDivisionalSecretariat(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDivisionalSecretariat(<any>response_);
                } catch (e) {
                    return <Observable<DivisionalSecretariat[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DivisionalSecretariat[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDivisionalSecretariat(response: HttpResponseBase): Observable<DivisionalSecretariat[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DivisionalSecretariat.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DivisionalSecretariat[]>(<any>null);
    }

    getAllDivisionalSecretariatByDistrict(districtId: number): Observable<DivisionalSecretariat[]> {
        let url_ = this.baseUrl + "/masterdata/divisional-secretariat/{districtId}";
        if (districtId === undefined || districtId === null)
            throw new Error("The parameter 'districtId' must be defined.");
        url_ = url_.replace("{districtId}", encodeURIComponent("" + districtId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDivisionalSecretariatByDistrict(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDivisionalSecretariatByDistrict(<any>response_);
                } catch (e) {
                    return <Observable<DivisionalSecretariat[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DivisionalSecretariat[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDivisionalSecretariatByDistrict(response: HttpResponseBase): Observable<DivisionalSecretariat[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DivisionalSecretariat.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DivisionalSecretariat[]>(<any>null);
    }

    getAllDivisionalSecretariatByProvince(provinceId: number): Observable<DivisionalSecretariat[]> {
        let url_ = this.baseUrl + "/masterdata/divisional-secretariat/province/{provinceId}?";
        if (provinceId === undefined || provinceId === null)
            throw new Error("The parameter 'provinceId' must be defined and cannot be null.");
        else
            url_ += "provinceId=" + encodeURIComponent("" + provinceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllDivisionalSecretariatByProvince(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllDivisionalSecretariatByProvince(<any>response_);
                } catch (e) {
                    return <Observable<DivisionalSecretariat[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DivisionalSecretariat[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllDivisionalSecretariatByProvince(response: HttpResponseBase): Observable<DivisionalSecretariat[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(DivisionalSecretariat.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DivisionalSecretariat[]>(<any>null);
    }

    getAllParameterDataTypes(): Observable<ParameterDataType[]> {
        let url_ = this.baseUrl + "/masterdata/parameter-data-type";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllParameterDataTypes(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllParameterDataTypes(<any>response_);
                } catch (e) {
                    return <Observable<ParameterDataType[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterDataType[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllParameterDataTypes(response: HttpResponseBase): Observable<ParameterDataType[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(ParameterDataType.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterDataType[]>(<any>null);
    }
}

@Injectable()
export class ParameterControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getNotRequestedParametera(page: number, limit: number, frequncyId: number, fromDate: any, toDate: any, insutationId: number, paramName: string): Observable<any> {
        let url_ = this.baseUrl + "/parameter/parameter/NotRequestedParametera/{page}/{limit}/{frequncyId}/{fromDate}/{toDate}/{insutationId}/{paramName}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (frequncyId === undefined || frequncyId === null)
            throw new Error("The parameter 'frequncyId' must be defined and cannot be null.");
        else
            url_ += "frequncyId=" + encodeURIComponent("" + frequncyId) + "&";
        if (fromDate === undefined || fromDate === null)
            throw new Error("The parameter 'fromDate' must be defined and cannot be null.");
        else
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate === undefined || toDate === null)
            throw new Error("The parameter 'toDate' must be defined and cannot be null.");
        else
            url_ += "toDate=" + encodeURIComponent("" + toDate) + "&";
        if (insutationId === undefined || insutationId === null)
            throw new Error("The parameter 'insutationId' must be defined and cannot be null.");
        else
            url_ += "insutationId=" + encodeURIComponent("" + insutationId) + "&";
        if (paramName === undefined || paramName === null)
            throw new Error("The parameter 'paramName' must be defined and cannot be null.");
        else
            url_ += "paramName=" + encodeURIComponent("" + paramName) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNotRequestedParametera(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNotRequestedParametera(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetNotRequestedParametera(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getRequestedParametera(page: number, limit: number, frequncyId: number, fromDate: any, toDate: any, insutationId: number, paramName: string, statusId: number): Observable<any> {
        let url_ = this.baseUrl + "/parameter/parameter/RequestedParametera/{page}/{limit}/{frequncyId}/{fromDate}/{toDate}/{insutationId}/{statusId}/{paramName}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (frequncyId === undefined || frequncyId === null)
            throw new Error("The parameter 'frequncyId' must be defined and cannot be null.");
        else
            url_ += "frequncyId=" + encodeURIComponent("" + frequncyId) + "&";
        if (fromDate === undefined || fromDate === null)
            throw new Error("The parameter 'fromDate' must be defined and cannot be null.");
        else
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate === undefined || toDate === null)
            throw new Error("The parameter 'toDate' must be defined and cannot be null.");
        else
            url_ += "toDate=" + encodeURIComponent("" + toDate) + "&";
        if (insutationId === undefined || insutationId === null)
            throw new Error("The parameter 'insutationId' must be defined and cannot be null.");
        else
            url_ += "insutationId=" + encodeURIComponent("" + insutationId) + "&";
        if (paramName === undefined || paramName === null)
            throw new Error("The parameter 'paramName' must be defined and cannot be null.");
        else
            url_ += "paramName=" + encodeURIComponent("" + paramName) + "&";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined and cannot be null.");
        else
            url_ += "statusId=" + encodeURIComponent("" + statusId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestedParametera(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestedParametera(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestedParametera(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getRequestedParameteraForCCSAdminApprove(page: number, limit: number, frequncyId: number, fromDate: any, toDate: any, insutationId: number): Observable<any> {
        let url_ = this.baseUrl + "/parameter/parameter/getRequestedParameteraForCCSAdminApprove/{page}/{limit}/{frequncyId}/{insutationId}/{fromDate}/{toDate}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (frequncyId === undefined || frequncyId === null)
            throw new Error("The parameter 'frequncyId' must be defined and cannot be null.");
        else
            url_ += "frequncyId=" + encodeURIComponent("" + frequncyId) + "&";
        if (fromDate === undefined || fromDate === null)
            throw new Error("The parameter 'fromDate' must be defined and cannot be null.");
        else
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate === undefined || toDate === null)
            throw new Error("The parameter 'toDate' must be defined and cannot be null.");
        else
            url_ += "toDate=" + encodeURIComponent("" + toDate) + "&";
        if (insutationId === undefined || insutationId === null)
            throw new Error("The parameter 'insutationId' must be defined and cannot be null.");
        else
            url_ += "insutationId=" + encodeURIComponent("" + insutationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestedParameteraForCCSAdminApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestedParameteraForCCSAdminApprove(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestedParameteraForCCSAdminApprove(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getRequestedParameteraForInstutionAdminApprove(page: number, limit: number, insutationId: number): Observable<any> {
        let url_ = this.baseUrl + "/parameter/parameter/getRequestedParameteraForInstutionAdminApprove/{page}/{limit}/{insutationId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (insutationId === undefined || insutationId === null)
            throw new Error("The parameter 'insutationId' must be defined and cannot be null.");
        else
            url_ += "insutationId=" + encodeURIComponent("" + insutationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestedParameteraForInstutionAdminApprove(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestedParameteraForInstutionAdminApprove(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestedParameteraForInstutionAdminApprove(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getRequestedParameteraForDataEntry(page: number, limit: number, insutationId: number, userId: number): Observable<any> {
        let url_ = this.baseUrl + "/parameter/parameter/getRequestedParameteraForDataEntry/{page}/{limit}/{insutationId}/{userId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (insutationId === undefined || insutationId === null)
            throw new Error("The parameter 'insutationId' must be defined and cannot be null.");
        else
            url_ += "insutationId=" + encodeURIComponent("" + insutationId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestedParameteraForDataEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestedParameteraForDataEntry(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestedParameteraForDataEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getRequestedParameteraForHistory(page: number, limit: number, fromDate: any, toDate: any, insutationId: number): Observable<any> {
        let url_ = this.baseUrl + "/parameter/parameter/getRequestedParameteraForHistory/{page}/{limit}/{fromDate}/{toDate}/{insutationId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (fromDate === undefined || fromDate === null)
            throw new Error("The parameter 'fromDate' must be defined and cannot be null.");
        else
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate === undefined || toDate === null)
            throw new Error("The parameter 'toDate' must be defined and cannot be null.");
        else
            url_ += "toDate=" + encodeURIComponent("" + toDate) + "&";
        if (insutationId === undefined || insutationId === null)
            throw new Error("The parameter 'insutationId' must be defined and cannot be null.");
        else
            url_ += "insutationId=" + encodeURIComponent("" + insutationId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestedParameteraForHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestedParameteraForHistory(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestedParameteraForHistory(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getRequestedParameteraForDataAssign(page: number, limit: number, insutationId: number, statusId: number): Observable<any> {
        let url_ = this.baseUrl + "/parameter/parameter/getRequestedParameteraForDataAssign/{page}/{limit}/{insutationId}/{statusId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (insutationId === undefined || insutationId === null)
            throw new Error("The parameter 'insutationId' must be defined and cannot be null.");
        else
            url_ += "insutationId=" + encodeURIComponent("" + insutationId) + "&";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined and cannot be null.");
        else
            url_ += "statusId=" + encodeURIComponent("" + statusId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestedParameteraForDataAssign(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestedParameteraForDataAssign(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestedParameteraForDataAssign(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getRequestedParameteraForAssigneddata(page: number, limit: number, insutationId: number, userId: number, statusId: number): Observable<any> {
        let url_ = this.baseUrl + "/parameter/parameter/getRequestedParameteraForDataAssign/{page}/{limit}/{insutationId}/{userId}/{statusId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (insutationId === undefined || insutationId === null)
            throw new Error("The parameter 'insutationId' must be defined and cannot be null.");
        else
            url_ += "insutationId=" + encodeURIComponent("" + insutationId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined and cannot be null.");
        else
            url_ += "statusId=" + encodeURIComponent("" + statusId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestedParameteraForAssigneddata(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestedParameteraForAssigneddata(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestedParameteraForAssigneddata(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    searchParameterLocationData(page: number, limit: number, fromDate: string, toDate: string, sectorId: number, name: string, climateChangeCategoryId: number, institutionId: number): Observable<any> {
        let url_ = this.baseUrl + "/parameter/parameter/searchParameterLocationData/{page}/{limit}/{fromDate}/{toDate}/{sectorId}/{name}/{climateChangeCategoryId}/{institutionId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (fromDate === undefined || fromDate === null)
            throw new Error("The parameter 'fromDate' must be defined and cannot be null.");
        else
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate === undefined || toDate === null)
            throw new Error("The parameter 'toDate' must be defined and cannot be null.");
        else
            url_ += "toDate=" + encodeURIComponent("" + toDate) + "&";
        if (sectorId === undefined || sectorId === null)
            throw new Error("The parameter 'sectorId' must be defined and cannot be null.");
        else
            url_ += "sectorId=" + encodeURIComponent("" + sectorId) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (climateChangeCategoryId === undefined || climateChangeCategoryId === null)
            throw new Error("The parameter 'climateChangeCategoryId' must be defined and cannot be null.");
        else
            url_ += "climateChangeCategoryId=" + encodeURIComponent("" + climateChangeCategoryId) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSearchParameterLocationData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSearchParameterLocationData(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processSearchParameterLocationData(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    create(body: Parameter): Observable<Parameter> {
        let url_ = this.baseUrl + "/parameter/sync-location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Parameter>><any>_observableThrow(e);
                }
            } else
                return <Observable<Parameter>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Parameter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = Parameter.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Parameter>(<any>null);
    }

    getDataForPurchase(page: number, limit: number, fromDate: string, toDate: string, sectorId: number, name: string, categoryId: number, provinceId: number, districtId: number, dsId: number): Observable<any> {
        let url_ = this.baseUrl + "/parameter/purchase-data/{page}/{limit}/{fromDate}/{toDate}/{sectorId}/{name}/{categoryId}/{provinceId}/{districtId}/{dsId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (fromDate === undefined || fromDate === null)
            throw new Error("The parameter 'fromDate' must be defined and cannot be null.");
        else
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate === undefined || toDate === null)
            throw new Error("The parameter 'toDate' must be defined and cannot be null.");
        else
            url_ += "toDate=" + encodeURIComponent("" + toDate) + "&";
        if (sectorId === undefined || sectorId === null)
            throw new Error("The parameter 'sectorId' must be defined and cannot be null.");
        else
            url_ += "sectorId=" + encodeURIComponent("" + sectorId) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (categoryId === undefined || categoryId === null)
            throw new Error("The parameter 'categoryId' must be defined and cannot be null.");
        else
            url_ += "categoryId=" + encodeURIComponent("" + categoryId) + "&";
        if (provinceId === undefined || provinceId === null)
            throw new Error("The parameter 'provinceId' must be defined and cannot be null.");
        else
            url_ += "provinceId=" + encodeURIComponent("" + provinceId) + "&";
        if (districtId === undefined || districtId === null)
            throw new Error("The parameter 'districtId' must be defined and cannot be null.");
        else
            url_ += "districtId=" + encodeURIComponent("" + districtId) + "&";
        if (dsId === undefined || dsId === null)
            throw new Error("The parameter 'dsId' must be defined and cannot be null.");
        else
            url_ += "dsId=" + encodeURIComponent("" + dsId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDataForPurchase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDataForPurchase(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetDataForPurchase(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class UnitOfMeasureControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getKindOfQuantityList(): Observable<string[]> {
        let url_ = this.baseUrl + "/unit-of-measure/kind-of-quantity";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetKindOfQuantityList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetKindOfQuantityList(<any>response_);
                } catch (e) {
                    return <Observable<string[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<string[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetKindOfQuantityList(response: HttpResponseBase): Observable<string[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(item);
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string[]>(<any>null);
    }
}

@Injectable()
export class ParameterLocationControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    updateLocations(body: ParameterLocationUpdateRequestDto): Observable<ParameterLocation[]> {
        let url_ = this.baseUrl + "/parameter-location/update-location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLocations(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLocations(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocation[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLocations(response: HttpResponseBase): Observable<ParameterLocation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ParameterLocation.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocation[]>(<any>null);
    }

    updateLocationsBulk(paramterId: number, dataSourceId: number): Observable<ParameterLocation[]> {
        let url_ = this.baseUrl + "/parameter-location/update-location-bulk/{paramterId}/{dataSourceId}?";
        if (paramterId === undefined || paramterId === null)
            throw new Error("The parameter 'paramterId' must be defined and cannot be null.");
        else
            url_ += "paramterId=" + encodeURIComponent("" + paramterId) + "&";
        if (dataSourceId === undefined || dataSourceId === null)
            throw new Error("The parameter 'dataSourceId' must be defined and cannot be null.");
        else
            url_ += "dataSourceId=" + encodeURIComponent("" + dataSourceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLocationsBulk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLocationsBulk(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocation[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLocationsBulk(response: HttpResponseBase): Observable<ParameterLocation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ParameterLocation.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocation[]>(<any>null);
    }

    updateLocationsSource(body: ParameterLocationUpdateRequestDto): Observable<ParameterLocation[]> {
        let url_ = this.baseUrl + "/parameter-location/update-location-source";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateLocationsSource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateLocationsSource(<any>response_);
                } catch (e) {
                    return <Observable<ParameterLocation[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ParameterLocation[]>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateLocationsSource(response: HttpResponseBase): Observable<ParameterLocation[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData201)) {
                result201 = [] as any;
                for (let item of resultData201)
                    result201.push(ParameterLocation.fromJS(item));
            }
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ParameterLocation[]>(<any>null);
    }

    deleteLocation(body: ParameterLocation): Observable<boolean> {
        let url_ = this.baseUrl + "/parameter-location/delete-location";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteLocation(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteLocation(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteLocation(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class DatarequestStatusHistoryControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getAuditDetails(page: number, limit: number, featureId: number, userId: number, fromDate: any, toDate: any): Observable<any> {
        let url_ = this.baseUrl + "/datarequest-status-history/audit/auditinfo/{page}/{limit}/{featureId}/{userId}/{fromDate}/{toDate}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (featureId === undefined || featureId === null)
            throw new Error("The parameter 'featureId' must be defined and cannot be null.");
        else
            url_ += "featureId=" + encodeURIComponent("" + featureId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        if (fromDate === undefined || fromDate === null)
            throw new Error("The parameter 'fromDate' must be defined and cannot be null.");
        else
            url_ += "fromDate=" + encodeURIComponent("" + fromDate) + "&";
        if (toDate === undefined || toDate === null)
            throw new Error("The parameter 'toDate' must be defined and cannot be null.");
        else
            url_ += "toDate=" + encodeURIComponent("" + toDate) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAuditDetails(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAuditDetails(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetAuditDetails(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class ShoppingCartControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    addItemToCart(body: PurchaseParameterDataRecordDto): Observable<ShoppingCartUpdateResponseDto> {
        let url_ = this.baseUrl + "/shopping-cart/add-item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddItemToCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddItemToCart(<any>response_);
                } catch (e) {
                    return <Observable<ShoppingCartUpdateResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShoppingCartUpdateResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processAddItemToCart(response: HttpResponseBase): Observable<ShoppingCartUpdateResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ShoppingCartUpdateResponseDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShoppingCartUpdateResponseDto>(<any>null);
    }

    removeItemFromCart(parameterDataId: number): Observable<ShoppingCartUpdateResponseDto> {
        let url_ = this.baseUrl + "/shopping-cart/remove-item/{parameterDataId}?";
        if (parameterDataId === undefined || parameterDataId === null)
            throw new Error("The parameter 'parameterDataId' must be defined and cannot be null.");
        else
            url_ += "parameterDataId=" + encodeURIComponent("" + parameterDataId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveItemFromCart(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveItemFromCart(<any>response_);
                } catch (e) {
                    return <Observable<ShoppingCartUpdateResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShoppingCartUpdateResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processRemoveItemFromCart(response: HttpResponseBase): Observable<ShoppingCartUpdateResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = ShoppingCartUpdateResponseDto.fromJS(resultData201);
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShoppingCartUpdateResponseDto>(<any>null);
    }

    getActiveCartSummary(): Observable<ShoppingCartUpdateResponseDto> {
        let url_ = this.baseUrl + "/shopping-cart/summary";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetActiveCartSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetActiveCartSummary(<any>response_);
                } catch (e) {
                    return <Observable<ShoppingCartUpdateResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShoppingCartUpdateResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetActiveCartSummary(response: HttpResponseBase): Observable<ShoppingCartUpdateResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCartUpdateResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShoppingCartUpdateResponseDto>(<any>null);
    }

    checkout(): Observable<any> {
        let url_ = this.baseUrl + "/shopping-cart/checkout";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckout(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckout(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processCheckout(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    checkoutResponse(transactionID: number, transactionStatus: string, transactionReferenceNumber: string, paymentGatewayName: string, convenienceFee: string, dataHash: string): Observable<void> {
        let url_ = this.baseUrl + "/shopping-cart/checkout-response?";
        if (transactionID === undefined || transactionID === null)
            throw new Error("The parameter 'transactionID' must be defined and cannot be null.");
        else
            url_ += "transactionID=" + encodeURIComponent("" + transactionID) + "&";
        if (transactionStatus === undefined || transactionStatus === null)
            throw new Error("The parameter 'transactionStatus' must be defined and cannot be null.");
        else
            url_ += "transactionStatus=" + encodeURIComponent("" + transactionStatus) + "&";
        if (transactionReferenceNumber === undefined || transactionReferenceNumber === null)
            throw new Error("The parameter 'transactionReferenceNumber' must be defined and cannot be null.");
        else
            url_ += "transactionReferenceNumber=" + encodeURIComponent("" + transactionReferenceNumber) + "&";
        if (paymentGatewayName === undefined || paymentGatewayName === null)
            throw new Error("The parameter 'paymentGatewayName' must be defined and cannot be null.");
        else
            url_ += "paymentGatewayName=" + encodeURIComponent("" + paymentGatewayName) + "&";
        if (convenienceFee === undefined || convenienceFee === null)
            throw new Error("The parameter 'convenienceFee' must be defined and cannot be null.");
        else
            url_ += "convenienceFee=" + encodeURIComponent("" + convenienceFee) + "&";
        if (dataHash === undefined || dataHash === null)
            throw new Error("The parameter 'dataHash' must be defined and cannot be null.");
        else
            url_ += "dataHash=" + encodeURIComponent("" + dataHash) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckoutResponse(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckoutResponse(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processCheckoutResponse(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getPaidCartSummary(transactionReferenceNumber: string): Observable<ShoppingCartUpdateResponseDto> {
        let url_ = this.baseUrl + "/shopping-cart/get-paid-cart?";
        if (transactionReferenceNumber === undefined || transactionReferenceNumber === null)
            throw new Error("The parameter 'transactionReferenceNumber' must be defined and cannot be null.");
        else
            url_ += "transactionReferenceNumber=" + encodeURIComponent("" + transactionReferenceNumber) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPaidCartSummary(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPaidCartSummary(<any>response_);
                } catch (e) {
                    return <Observable<ShoppingCartUpdateResponseDto>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShoppingCartUpdateResponseDto>><any>_observableThrow(response_);
        }));
    }

    protected processGetPaidCartSummary(response: HttpResponseBase): Observable<ShoppingCartUpdateResponseDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ShoppingCartUpdateResponseDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShoppingCartUpdateResponseDto>(<any>null);
    }
}

@Injectable()
export class PolicyControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getPolicyList(page: number, limit: number, name: string, sector: number, ccdCatagary: number, instutionId: number, formulationInstitution: string, isApprove: number): Observable<any> {
        let url_ = this.baseUrl + "/policy/policylist/{page}/{limit}/{name}/{sector}/{ccdCatagary}/{instutionId}/{formulationInstitution}/{isApprove}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        if (sector === undefined || sector === null)
            throw new Error("The parameter 'sector' must be defined and cannot be null.");
        else
            url_ += "sector=" + encodeURIComponent("" + sector) + "&";
        if (ccdCatagary === undefined || ccdCatagary === null)
            throw new Error("The parameter 'ccdCatagary' must be defined and cannot be null.");
        else
            url_ += "ccdCatagary=" + encodeURIComponent("" + ccdCatagary) + "&";
        if (instutionId === undefined || instutionId === null)
            throw new Error("The parameter 'instutionId' must be defined and cannot be null.");
        else
            url_ += "instutionId=" + encodeURIComponent("" + instutionId) + "&";
        if (formulationInstitution === undefined || formulationInstitution === null)
            throw new Error("The parameter 'formulationInstitution' must be defined and cannot be null.");
        else
            url_ += "formulationInstitution=" + encodeURIComponent("" + formulationInstitution) + "&";
        if (isApprove === undefined || isApprove === null)
            throw new Error("The parameter 'isApprove' must be defined and cannot be null.");
        else
            url_ += "isApprove=" + encodeURIComponent("" + isApprove) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPolicyList(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPolicyList(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPolicyList(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }
}

@Injectable()
export class DocumentControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    uploadFile(body: Documents): Observable<void> {
        let url_ = this.baseUrl + "/document/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    uploadFile2(): Observable<void> {
        let url_ = this.baseUrl + "/document/upload2/{oid}/{owner}";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile2(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile2(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    uploadFile3(): Observable<void> {
        let url_ = this.baseUrl + "/document/upload3/{oid}";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadFile3(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadFile3(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processUploadFile3(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    deleteDoc(docId: number): Observable<void> {
        let url_ = this.baseUrl + "/document/delete/{docId}";
        if (docId === undefined || docId === null)
            throw new Error("The parameter 'docId' must be defined.");
        url_ = url_.replace("{docId}", encodeURIComponent("" + docId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDoc(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDoc(<any>response_);
                } catch (e) {
                    return <Observable<void>><any>_observableThrow(e);
                }
            } else
                return <Observable<void>><any>_observableThrow(response_);
        }));
    }

    protected processDeleteDoc(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return _observableOf<void>(<any>null);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<void>(<any>null);
    }

    getDocuments(oid: number, owner: number): Observable<Documents[]> {
        let url_ = this.baseUrl + "/document/getDocument/{oid}/{owner}";
        if (oid === undefined || oid === null)
            throw new Error("The parameter 'oid' must be defined.");
        url_ = url_.replace("{oid}", encodeURIComponent("" + oid));
        if (owner === undefined || owner === null)
            throw new Error("The parameter 'owner' must be defined.");
        url_ = url_.replace("{owner}", encodeURIComponent("" + owner));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDocuments(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDocuments(<any>response_);
                } catch (e) {
                    return <Observable<Documents[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Documents[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetDocuments(response: HttpResponseBase): Observable<Documents[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            if (Array.isArray(resultData200)) {
                result200 = [] as any;
                for (let item of resultData200)
                    result200.push(Documents.fromJS(item));
            }
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Documents[]>(<any>null);
    }
}

@Injectable()
export class ProjectProgramDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getProjectsAvailableForDataRequest(page: number, limit: number, institutionId: number, year: number, name: string): Observable<any> {
        let url_ = this.baseUrl + "/project-program-data/available-to-request/{page}/{limit}/{institutionId}/{year}/{name}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined and cannot be null.");
        else
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined and cannot be null.");
        else
            url_ += "name=" + encodeURIComponent("" + name) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectsAvailableForDataRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectsAvailableForDataRequest(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectsAvailableForDataRequest(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getProjectDataRequested(page: number, limit: number, institutionId: number, year: number, statusId: number): Observable<any> {
        let url_ = this.baseUrl + "/project-program-data/requested/{page}/{limit}/{institutionId}/{year}/{statusId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined and cannot be null.");
        else
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined and cannot be null.");
        else
            url_ += "statusId=" + encodeURIComponent("" + statusId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectDataRequested(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectDataRequested(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectDataRequested(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getRequestsListforHistory(page: number, limit: number, institutionId: number, fromyear: number, toyear: number): Observable<any> {
        let url_ = this.baseUrl + "/project-program-data/projectrequesthistory/{page}/{limit}/{institutionId}/{fromyear}/{toyear}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        if (fromyear === undefined || fromyear === null)
            throw new Error("The parameter 'fromyear' must be defined and cannot be null.");
        else
            url_ += "fromyear=" + encodeURIComponent("" + fromyear) + "&";
        if (toyear === undefined || toyear === null)
            throw new Error("The parameter 'toyear' must be defined and cannot be null.");
        else
            url_ += "toyear=" + encodeURIComponent("" + toyear) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestsListforHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestsListforHistory(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestsListforHistory(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getProjectDataRequestsOfInstitution(page: number, limit: number, institutionId: number, statusId: number): Observable<any> {
        let url_ = this.baseUrl + "/project-program-data/institution-requested-data/{page}/{limit}/{institutionId}/{statusId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined and cannot be null.");
        else
            url_ += "statusId=" + encodeURIComponent("" + statusId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectDataRequestsOfInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectDataRequestsOfInstitution(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectDataRequestsOfInstitution(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getProjectDataRequestsOfDataEntryUser(page: number, limit: number, institutionId: number, statusId: number, userId: number): Observable<any> {
        let url_ = this.baseUrl + "/project-program-data/institution-assigned-data/{page}/{limit}/{institutionId}/{statusId}/{userId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined and cannot be null.");
        else
            url_ += "statusId=" + encodeURIComponent("" + statusId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectDataRequestsOfDataEntryUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectDataRequestsOfDataEntryUser(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectDataRequestsOfDataEntryUser(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getProjectDataRequestsToDataEntry(page: number, limit: number, institutionId: number, userId: number): Observable<any> {
        let url_ = this.baseUrl + "/project-program-data/institution-assigned-data/{page}/{limit}/{institutionId}/{userId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetProjectDataRequestsToDataEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetProjectDataRequestsToDataEntry(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetProjectDataRequestsToDataEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    assignToProjectDataEntryUser(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/project-program-data/institution-requested-data/assign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignToProjectDataEntryUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignToProjectDataEntryUser(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAssignToProjectDataEntryUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    saveProjectData(body: ProjectDataSaveRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/project-program-data/institution-requested-data/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveProjectData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveProjectData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSaveProjectData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    approveProjectData(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/project-program-data/institution-requested-data/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveProjectData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveProjectData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApproveProjectData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    rejectProjectData(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/project-program-data/institution-requested-data/reject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectProjectData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectProjectData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRejectProjectData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    approveProjectDataFromCCS(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/project-program-data/institution-requested-data/approve-from-ccs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApproveProjectDataFromCCS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApproveProjectDataFromCCS(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApproveProjectDataFromCCS(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    rejectProjectDataFromCCS(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/project-program-data/institution-requested-data/reject-from-ccs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectProjectDataFromCCS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectProjectDataFromCCS(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRejectProjectDataFromCCS(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    cancelProjectDataFromCCS(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/project-program-data/institution-requested-data/cancel-from-ccs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelProjectDataFromCCS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelProjectDataFromCCS(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCancelProjectDataFromCCS(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    rejectProjectDataFromIA(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/project-program-data/institution-requested-data/reject-from-ia";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectProjectDataFromIA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectProjectDataFromIA(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRejectProjectDataFromIA(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class PolicyDataControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getInstitutionsAvailableForDataRequest(page: number, limit: number, year: number): Observable<any> {
        let url_ = this.baseUrl + "/policy-data/available-to-request/{page}/{limit}/{year}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined and cannot be null.");
        else
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetInstitutionsAvailableForDataRequest(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetInstitutionsAvailableForDataRequest(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetInstitutionsAvailableForDataRequest(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getPolicyDataRequested(page: number, limit: number, institutionId: number, year: number, statusId: number): Observable<any> {
        let url_ = this.baseUrl + "/policy-data/requested/{page}/{limit}/{institutionId}/{year}/{statusId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        if (year === undefined || year === null)
            throw new Error("The parameter 'year' must be defined and cannot be null.");
        else
            url_ += "year=" + encodeURIComponent("" + year) + "&";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined and cannot be null.");
        else
            url_ += "statusId=" + encodeURIComponent("" + statusId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPolicyDataRequested(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPolicyDataRequested(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPolicyDataRequested(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getRequestsListforHistory(page: number, limit: number, institutionId: number, fromyear: number, toyear: number): Observable<any> {
        let url_ = this.baseUrl + "/policy-data/policyrequesthistory/{page}/{limit}/{institutionId}/{fromyear}/{toyear}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        if (fromyear === undefined || fromyear === null)
            throw new Error("The parameter 'fromyear' must be defined and cannot be null.");
        else
            url_ += "fromyear=" + encodeURIComponent("" + fromyear) + "&";
        if (toyear === undefined || toyear === null)
            throw new Error("The parameter 'toyear' must be defined and cannot be null.");
        else
            url_ += "toyear=" + encodeURIComponent("" + toyear) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetRequestsListforHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetRequestsListforHistory(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetRequestsListforHistory(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    requestForDataByCCS(body: PolicyDataRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/policy-data/request";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestForDataByCCS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestForDataByCCS(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRequestForDataByCCS(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    getPolicyDataRequestsOfInstitution(page: number, limit: number, institutionId: number, statusId: number): Observable<any> {
        let url_ = this.baseUrl + "/policy-data/institution-requested-data/{page}/{limit}/{institutionId}/{statusId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined and cannot be null.");
        else
            url_ += "statusId=" + encodeURIComponent("" + statusId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPolicyDataRequestsOfInstitution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPolicyDataRequestsOfInstitution(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPolicyDataRequestsOfInstitution(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getPolicyDataRequestsOfDataEntryUser(page: number, limit: number, institutionId: number, statusId: number, userId: number): Observable<any> {
        let url_ = this.baseUrl + "/policy-data/institution-assigned-data/{page}/{limit}/{institutionId}/{statusId}/{userId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        if (statusId === undefined || statusId === null)
            throw new Error("The parameter 'statusId' must be defined and cannot be null.");
        else
            url_ += "statusId=" + encodeURIComponent("" + statusId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPolicyDataRequestsOfDataEntryUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPolicyDataRequestsOfDataEntryUser(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPolicyDataRequestsOfDataEntryUser(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    getPolicyDataRequestsToDataEntry(page: number, limit: number, institutionId: number, userId: number): Observable<any> {
        let url_ = this.baseUrl + "/policy-data/institution-assigned-data/{page}/{limit}/{institutionId}/{userId}?";
        if (page === undefined || page === null)
            throw new Error("The parameter 'page' must be defined and cannot be null.");
        else
            url_ += "page=" + encodeURIComponent("" + page) + "&";
        if (limit === undefined || limit === null)
            throw new Error("The parameter 'limit' must be defined and cannot be null.");
        else
            url_ += "limit=" + encodeURIComponent("" + limit) + "&";
        if (institutionId === undefined || institutionId === null)
            throw new Error("The parameter 'institutionId' must be defined and cannot be null.");
        else
            url_ += "institutionId=" + encodeURIComponent("" + institutionId) + "&";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined and cannot be null.");
        else
            url_ += "userId=" + encodeURIComponent("" + userId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetPolicyDataRequestsToDataEntry(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetPolicyDataRequestsToDataEntry(<any>response_);
                } catch (e) {
                    return <Observable<any>><any>_observableThrow(e);
                }
            } else
                return <Observable<any>><any>_observableThrow(response_);
        }));
    }

    protected processGetPolicyDataRequestsToDataEntry(response: HttpResponseBase): Observable<any> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = resultData200 !== undefined ? resultData200 : <any>null;
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<any>(<any>null);
    }

    assignToPolicyDataEntryUser(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/policy-data/institution-requested-data/assign";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAssignToPolicyDataEntryUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAssignToPolicyDataEntryUser(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processAssignToPolicyDataEntryUser(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    savePolicyData(body: PolicyDataSaveRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/policy-data/institution-requested-data/save";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSavePolicyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSavePolicyData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processSavePolicyData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    approvePolicyData(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/policy-data/institution-requested-data/approve";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprovePolicyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprovePolicyData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApprovePolicyData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    rejectPolicyData(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/policy-data/institution-requested-data/reject";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectPolicyData(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectPolicyData(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRejectPolicyData(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    approvePolicyDataFromCCS(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/policy-data/institution-requested-data/approve-from-ccs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processApprovePolicyDataFromCCS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processApprovePolicyDataFromCCS(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processApprovePolicyDataFromCCS(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    rejectPolicyDataFromCCS(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/policy-data/institution-requested-data/reject-from-ccs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectPolicyDataFromCCS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectPolicyDataFromCCS(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRejectPolicyDataFromCCS(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    cancelPolicyDataFromCCS(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/policy-data/institution-requested-data/cancel-from-ccs";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCancelPolicyDataFromCCS(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCancelPolicyDataFromCCS(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCancelPolicyDataFromCCS(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    rejectPolicyDataFromIA(body: ProjectDataAssignRequest): Observable<boolean> {
        let url_ = this.baseUrl + "/policy-data/institution-requested-data/reject-from-IA";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRejectPolicyDataFromIA(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRejectPolicyDataFromIA(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processRejectPolicyDataFromIA(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

@Injectable()
export class UserDataUsageCategoryControllerServiceProxy {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(API_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ? baseUrl : "";
    }

    getUserDataCategory(): Observable<UserDataUsageCategory> {
        let url_ = this.baseUrl + "/user-data-usage-category/getUserDataCategory";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetUserDataCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetUserDataCategory(<any>response_);
                } catch (e) {
                    return <Observable<UserDataUsageCategory>><any>_observableThrow(e);
                }
            } else
                return <Observable<UserDataUsageCategory>><any>_observableThrow(response_);
        }));
    }

    protected processGetUserDataCategory(response: HttpResponseBase): Observable<UserDataUsageCategory> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = UserDataUsageCategory.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UserDataUsageCategory>(<any>null);
    }

    updateUserDataCategory(body: DataUsageCategory): Observable<boolean> {
        let url_ = this.baseUrl + "/user-data-usage-category/updateUserDataCategory";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(body);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUserDataCategory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUserDataCategory(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateUserDataCategory(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 201) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result201: any = null;
            let resultData201 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result201 = resultData201 !== undefined ? resultData201 : <any>null;
            return _observableOf(result201);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }
}

export class AuthCredentialDto implements IAuthCredentialDto {
    username: string;
    password: string;

    constructor(data?: IAuthCredentialDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): AuthCredentialDto {
        data = typeof data === 'object' ? data : {};
        let result = new AuthCredentialDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        return data; 
    }

    clone(): AuthCredentialDto {
        const json = this.toJSON();
        let result = new AuthCredentialDto();
        result.init(json);
        return result;
    }
}

export interface IAuthCredentialDto {
    username: string;
    password: string;
}

export class ResetPassword implements IResetPassword {
    email: string;
    token: string;
    password: string;

    constructor(data?: IResetPassword) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
            this.token = _data["token"];
            this.password = _data["password"];
        }
    }

    static fromJS(data: any): ResetPassword {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPassword();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        data["token"] = this.token;
        data["password"] = this.password;
        return data; 
    }

    clone(): ResetPassword {
        const json = this.toJSON();
        let result = new ResetPassword();
        result.init(json);
        return result;
    }
}

export interface IResetPassword {
    email: string;
    token: string;
    password: string;
}

export class ForgotPasswordDto implements IForgotPasswordDto {
    email: string;

    constructor(data?: IForgotPasswordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.email = _data["email"];
        }
    }

    static fromJS(data: any): ForgotPasswordDto {
        data = typeof data === 'object' ? data : {};
        let result = new ForgotPasswordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["email"] = this.email;
        return data; 
    }

    clone(): ForgotPasswordDto {
        const json = this.toJSON();
        let result = new ForgotPasswordDto();
        result.init(json);
        return result;
    }
}

export interface IForgotPasswordDto {
    email: string;
}

export class GetManyUserResponseDto implements IGetManyUserResponseDto {
    data: User[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUserResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(User.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUserResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUserResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyUserResponseDto {
        const json = this.toJSON();
        let result = new GetManyUserResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUserResponseDto {
    data: User[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyUserTypeResponseDto implements IGetManyUserTypeResponseDto {
    data: UserType[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUserTypeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(UserType.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUserTypeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUserTypeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyUserTypeResponseDto {
        const json = this.toJSON();
        let result = new GetManyUserTypeResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUserTypeResponseDto {
    data: UserType[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class UserType implements IUserType {
    userRoleIdIdentity: string;
    userRoleNameIdentity: string;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: UserTypeStatus;

    constructor(data?: IUserType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userRoleIdIdentity = _data["userRoleIdIdentity"];
            this.userRoleNameIdentity = _data["userRoleNameIdentity"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UserType {
        data = typeof data === 'object' ? data : {};
        let result = new UserType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userRoleIdIdentity"] = this.userRoleIdIdentity;
        data["userRoleNameIdentity"] = this.userRoleNameIdentity;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): UserType {
        const json = this.toJSON();
        let result = new UserType();
        result.init(json);
        return result;
    }
}

export interface IUserType {
    userRoleIdIdentity: string;
    userRoleNameIdentity: string;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: UserTypeStatus;
}

export class GetManyInstitutionResponseDto implements IGetManyInstitutionResponseDto {
    data: Institution[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyInstitutionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Institution.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyInstitutionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyInstitutionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyInstitutionResponseDto {
        const json = this.toJSON();
        let result = new GetManyInstitutionResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyInstitutionResponseDto {
    data: Institution[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class InstitutionCategory implements IInstitutionCategory {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: InstitutionCategoryStatus;

    constructor(data?: IInstitutionCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): InstitutionCategory {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): InstitutionCategory {
        const json = this.toJSON();
        let result = new InstitutionCategory();
        result.init(json);
        return result;
    }
}

export interface IInstitutionCategory {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: InstitutionCategoryStatus;
}

export class InstitutionType implements IInstitutionType {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: InstitutionTypeStatus;

    constructor(data?: IInstitutionType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): InstitutionType {
        data = typeof data === 'object' ? data : {};
        let result = new InstitutionType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): InstitutionType {
        const json = this.toJSON();
        let result = new InstitutionType();
        result.init(json);
        return result;
    }
}

export interface IInstitutionType {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: InstitutionTypeStatus;
}

export class Province implements IProvince {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProvinceStatus;

    constructor(data?: IProvince) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Province {
        data = typeof data === 'object' ? data : {};
        let result = new Province();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): Province {
        const json = this.toJSON();
        let result = new Province();
        result.init(json);
        return result;
    }
}

export interface IProvince {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProvinceStatus;
}

export class Hierarchy implements IHierarchy {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: HierarchyStatus;

    constructor(data?: IHierarchy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Hierarchy {
        data = typeof data === 'object' ? data : {};
        let result = new Hierarchy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): Hierarchy {
        const json = this.toJSON();
        let result = new Hierarchy();
        result.init(json);
        return result;
    }
}

export interface IHierarchy {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: HierarchyStatus;
}

export class District implements IDistrict {
    province: Province;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DistrictStatus;

    constructor(data?: IDistrict) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.province = new Province();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.province = _data["province"] ? Province.fromJS(_data["province"]) : new Province();
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): District {
        data = typeof data === 'object' ? data : {};
        let result = new District();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): District {
        const json = this.toJSON();
        let result = new District();
        result.init(json);
        return result;
    }
}

export interface IDistrict {
    province: Province;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DistrictStatus;
}

export class DivisionalSecretariat implements IDivisionalSecretariat {
    district: District;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DivisionalSecretariatStatus;

    constructor(data?: IDivisionalSecretariat) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.district = new District();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.district = _data["district"] ? District.fromJS(_data["district"]) : new District();
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): DivisionalSecretariat {
        data = typeof data === 'object' ? data : {};
        let result = new DivisionalSecretariat();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): DivisionalSecretariat {
        const json = this.toJSON();
        let result = new DivisionalSecretariat();
        result.init(json);
        return result;
    }
}

export interface IDivisionalSecretariat {
    district: District;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DivisionalSecretariatStatus;
}

export class Institution implements IInstitution {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    category: InstitutionCategory;
    type: InstitutionType;
    isNational: boolean;
    province: Province;
    hierarchy: Hierarchy;
    district: District;
    divisionalSecretariat: DivisionalSecretariat;
    parentInstitution: Institution;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: InstitutionStatus;

    constructor(data?: IInstitution) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.category = new InstitutionCategory();
            this.type = new InstitutionType();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.category = _data["category"] ? InstitutionCategory.fromJS(_data["category"]) : new InstitutionCategory();
            this.type = _data["type"] ? InstitutionType.fromJS(_data["type"]) : new InstitutionType();
            this.isNational = _data["isNational"];
            this.province = _data["province"] ? Province.fromJS(_data["province"]) : <any>undefined;
            this.hierarchy = _data["hierarchy"] ? Hierarchy.fromJS(_data["hierarchy"]) : <any>undefined;
            this.district = _data["district"] ? District.fromJS(_data["district"]) : <any>undefined;
            this.divisionalSecretariat = _data["divisionalSecretariat"] ? DivisionalSecretariat.fromJS(_data["divisionalSecretariat"]) : <any>undefined;
            this.parentInstitution = _data["parentInstitution"] ? Institution.fromJS(_data["parentInstitution"]) : <any>undefined;
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.canNotDelete = _data["canNotDelete"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Institution {
        data = typeof data === 'object' ? data : {};
        let result = new Institution();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["category"] = this.category ? this.category.toJSON() : <any>undefined;
        data["type"] = this.type ? this.type.toJSON() : <any>undefined;
        data["isNational"] = this.isNational;
        data["province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["hierarchy"] = this.hierarchy ? this.hierarchy.toJSON() : <any>undefined;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["divisionalSecretariat"] = this.divisionalSecretariat ? this.divisionalSecretariat.toJSON() : <any>undefined;
        data["parentInstitution"] = this.parentInstitution ? this.parentInstitution.toJSON() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["canNotDelete"] = this.canNotDelete;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): Institution {
        const json = this.toJSON();
        let result = new Institution();
        result.init(json);
        return result;
    }
}

export interface IInstitution {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    category: InstitutionCategory;
    type: InstitutionType;
    isNational: boolean;
    province: Province;
    hierarchy: Hierarchy;
    district: District;
    divisionalSecretariat: DivisionalSecretariat;
    parentInstitution: Institution;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: InstitutionStatus;
}

export class User implements IUser {
    id: number;
    userType: UserType;
    firstName: string;
    lastName: string;
    username: string;
    email: string;
    title: string;
    institution: Institution;
    designation: string;
    telephone: string;
    mobile: string;
    nic: string;
    salt: string;
    password: string;
    resetToken: string;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    fullName: string;
    _fullname: string;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: UserStatus;

    constructor(data?: IUser) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.userType = new UserType();
            this.institution = new Institution();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userType = _data["userType"] ? UserType.fromJS(_data["userType"]) : new UserType();
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.username = _data["username"];
            this.email = _data["email"];
            this.title = _data["title"];
            this.institution = _data["institution"] ? Institution.fromJS(_data["institution"]) : new Institution();
            this.designation = _data["designation"];
            this.telephone = _data["telephone"];
            this.mobile = _data["mobile"];
            this.nic = _data["nic"];
            this.salt = _data["salt"];
            this.password = _data["password"];
            this.resetToken = _data["resetToken"];
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.canNotDelete = _data["canNotDelete"];
            this.fullName = _data["fullName"];
            this._fullname = _data["_fullname"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): User {
        data = typeof data === 'object' ? data : {};
        let result = new User();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userType"] = this.userType ? this.userType.toJSON() : <any>undefined;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["username"] = this.username;
        data["email"] = this.email;
        data["title"] = this.title;
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        data["designation"] = this.designation;
        data["telephone"] = this.telephone;
        data["mobile"] = this.mobile;
        data["nic"] = this.nic;
        data["salt"] = this.salt;
        data["password"] = this.password;
        data["resetToken"] = this.resetToken;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["canNotDelete"] = this.canNotDelete;
        data["fullName"] = this.fullName;
        data["_fullname"] = this._fullname;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): User {
        const json = this.toJSON();
        let result = new User();
        result.init(json);
        return result;
    }
}

export interface IUser {
    id: number;
    userType: UserType;
    firstName: string;
    lastName: string;
    username: string;
    email: string;
    title: string;
    institution: Institution;
    designation: string;
    telephone: string;
    mobile: string;
    nic: string;
    salt: string;
    password: string;
    resetToken: string;
    deletedAt: moment.Moment;
    canNotDelete: boolean;
    fullName: string;
    _fullname: string;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: UserStatus;
}

export class ChartData implements IChartData {
    label: string;
    data: number[];
    backgroundColor: string;
    borderColor: string;

    constructor(data?: IChartData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.label = _data["label"];
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(item);
            }
            this.backgroundColor = _data["backgroundColor"];
            this.borderColor = _data["borderColor"];
        }
    }

    static fromJS(data: any): ChartData {
        data = typeof data === 'object' ? data : {};
        let result = new ChartData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["label"] = this.label;
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item);
        }
        data["backgroundColor"] = this.backgroundColor;
        data["borderColor"] = this.borderColor;
        return data; 
    }

    clone(): ChartData {
        const json = this.toJSON();
        let result = new ChartData();
        result.init(json);
        return result;
    }
}

export interface IChartData {
    label: string;
    data: number[];
    backgroundColor: string;
    borderColor: string;
}

export class ClimateChangeBarChart implements IClimateChangeBarChart {
    labels: string[];
    datasets: ChartData[];
    title: string;

    constructor(data?: IClimateChangeBarChart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.labels = [];
            this.datasets = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["labels"])) {
                this.labels = [] as any;
                for (let item of _data["labels"])
                    this.labels.push(item);
            }
            if (Array.isArray(_data["datasets"])) {
                this.datasets = [] as any;
                for (let item of _data["datasets"])
                    this.datasets.push(ChartData.fromJS(item));
            }
            this.title = _data["title"];
        }
    }

    static fromJS(data: any): ClimateChangeBarChart {
        data = typeof data === 'object' ? data : {};
        let result = new ClimateChangeBarChart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.labels)) {
            data["labels"] = [];
            for (let item of this.labels)
                data["labels"].push(item);
        }
        if (Array.isArray(this.datasets)) {
            data["datasets"] = [];
            for (let item of this.datasets)
                data["datasets"].push(item.toJSON());
        }
        data["title"] = this.title;
        return data; 
    }

    clone(): ClimateChangeBarChart {
        const json = this.toJSON();
        let result = new ClimateChangeBarChart();
        result.init(json);
        return result;
    }
}

export interface IClimateChangeBarChart {
    labels: string[];
    datasets: ChartData[];
    title: string;
}

export class GetManyProjectProgrammeResponseDto implements IGetManyProjectProgrammeResponseDto {
    data: ProjectProgramme[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyProjectProgrammeResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProjectProgramme.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectProgrammeResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectProgrammeResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyProjectProgrammeResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectProgrammeResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectProgrammeResponseDto {
    data: ProjectProgramme[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Currency implements ICurrency {
    multificationFactor: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: CurrencyStatus;

    constructor(data?: ICurrency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.multificationFactor = _data["multificationFactor"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Currency {
        data = typeof data === 'object' ? data : {};
        let result = new Currency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["multificationFactor"] = this.multificationFactor;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): Currency {
        const json = this.toJSON();
        let result = new Currency();
        result.init(json);
        return result;
    }
}

export interface ICurrency {
    multificationFactor: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: CurrencyStatus;
}

export class FinancingScheme implements IFinancingScheme {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: FinancingSchemeStatus;

    constructor(data?: IFinancingScheme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): FinancingScheme {
        data = typeof data === 'object' ? data : {};
        let result = new FinancingScheme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): FinancingScheme {
        const json = this.toJSON();
        let result = new FinancingScheme();
        result.init(json);
        return result;
    }
}

export interface IFinancingScheme {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: FinancingSchemeStatus;
}

export class SDBenefit implements ISDBenefit {
    isDirectBenefit: boolean;
    isInDirectBenefit: boolean;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: SDBenefitStatus;

    constructor(data?: ISDBenefit) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isDirectBenefit = _data["isDirectBenefit"];
            this.isInDirectBenefit = _data["isInDirectBenefit"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): SDBenefit {
        data = typeof data === 'object' ? data : {};
        let result = new SDBenefit();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isDirectBenefit"] = this.isDirectBenefit;
        data["isInDirectBenefit"] = this.isInDirectBenefit;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): SDBenefit {
        const json = this.toJSON();
        let result = new SDBenefit();
        result.init(json);
        return result;
    }
}

export interface ISDBenefit {
    isDirectBenefit: boolean;
    isInDirectBenefit: boolean;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: SDBenefitStatus;
}

export class GetManyProjectStatusResponseDto implements IGetManyProjectStatusResponseDto {
    data: ProjectStatus[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyProjectStatusResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProjectStatus.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectStatusResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectStatusResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyProjectStatusResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectStatusResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectStatusResponseDto {
    data: ProjectStatus[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class ProjectStatus implements IProjectStatus {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProjectStatusStatus;

    constructor(data?: IProjectStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ProjectStatus {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ProjectStatus {
        const json = this.toJSON();
        let result = new ProjectStatus();
        result.init(json);
        return result;
    }
}

export interface IProjectStatus {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProjectStatusStatus;
}

export class GetManyClimateChangeDataCategoryResponseDto implements IGetManyClimateChangeDataCategoryResponseDto {
    data: ClimateChangeDataCategory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyClimateChangeDataCategoryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ClimateChangeDataCategory.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyClimateChangeDataCategoryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyClimateChangeDataCategoryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyClimateChangeDataCategoryResponseDto {
        const json = this.toJSON();
        let result = new GetManyClimateChangeDataCategoryResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyClimateChangeDataCategoryResponseDto {
    data: ClimateChangeDataCategory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManySectorResponseDto implements IGetManySectorResponseDto {
    data: Sector[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManySectorResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Sector.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManySectorResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManySectorResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManySectorResponseDto {
        const json = this.toJSON();
        let result = new GetManySectorResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManySectorResponseDto {
    data: Sector[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Sector implements ISector {
    climateChangeDataCategory: ClimateChangeDataCategory;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: SectorStatus;

    constructor(data?: ISector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.climateChangeDataCategory = new ClimateChangeDataCategory();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.climateChangeDataCategory = _data["climateChangeDataCategory"] ? ClimateChangeDataCategory.fromJS(_data["climateChangeDataCategory"]) : new ClimateChangeDataCategory();
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Sector {
        data = typeof data === 'object' ? data : {};
        let result = new Sector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["climateChangeDataCategory"] = this.climateChangeDataCategory ? this.climateChangeDataCategory.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): Sector {
        const json = this.toJSON();
        let result = new Sector();
        result.init(json);
        return result;
    }
}

export interface ISector {
    climateChangeDataCategory: ClimateChangeDataCategory;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: SectorStatus;
}

export class ClimateChangeDataCategory implements IClimateChangeDataCategory {
    sectors: Sector[];
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ClimateChangeDataCategoryStatus;

    constructor(data?: IClimateChangeDataCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sectors = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sectors"])) {
                this.sectors = [] as any;
                for (let item of _data["sectors"])
                    this.sectors.push(Sector.fromJS(item));
            }
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ClimateChangeDataCategory {
        data = typeof data === 'object' ? data : {};
        let result = new ClimateChangeDataCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sectors)) {
            data["sectors"] = [];
            for (let item of this.sectors)
                data["sectors"].push(item.toJSON());
        }
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ClimateChangeDataCategory {
        const json = this.toJSON();
        let result = new ClimateChangeDataCategory();
        result.init(json);
        return result;
    }
}

export interface IClimateChangeDataCategory {
    sectors: Sector[];
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ClimateChangeDataCategoryStatus;
}

export class GetManySubSectorResponseDto implements IGetManySubSectorResponseDto {
    data: SubSector[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManySubSectorResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(SubSector.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManySubSectorResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManySubSectorResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManySubSectorResponseDto {
        const json = this.toJSON();
        let result = new GetManySubSectorResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManySubSectorResponseDto {
    data: SubSector[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class SubSector implements ISubSector {
    sector: Sector;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: SubSectorStatus;

    constructor(data?: ISubSector) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sector = new Sector();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : new Sector();
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): SubSector {
        data = typeof data === 'object' ? data : {};
        let result = new SubSector();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): SubSector {
        const json = this.toJSON();
        let result = new SubSector();
        result.init(json);
        return result;
    }
}

export interface ISubSector {
    sector: Sector;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: SubSectorStatus;
}

export class ProjectType implements IProjectType {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProjectTypeStatus;

    constructor(data?: IProjectType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ProjectType {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ProjectType {
        const json = this.toJSON();
        let result = new ProjectType();
        result.init(json);
        return result;
    }
}

export interface IProjectType {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProjectTypeStatus;
}

export class GetManyProjectProgramDataResponseDto implements IGetManyProjectProgramDataResponseDto {
    data: ProjectProgramData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyProjectProgramDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProjectProgramData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectProgramDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectProgramDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyProjectProgramDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectProgramDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectProgramDataResponseDto {
    data: ProjectProgramData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class DataRequestStatus implements IDataRequestStatus {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DataRequestStatusStatus;

    constructor(data?: IDataRequestStatus) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): DataRequestStatus {
        data = typeof data === 'object' ? data : {};
        let result = new DataRequestStatus();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): DataRequestStatus {
        const json = this.toJSON();
        let result = new DataRequestStatus();
        result.init(json);
        return result;
    }
}

export interface IDataRequestStatus {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DataRequestStatusStatus;
}

export class GetManyDocumentsResponseDto implements IGetManyDocumentsResponseDto {
    data: Documents[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyDocumentsResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Documents.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyDocumentsResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyDocumentsResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyDocumentsResponseDto {
        const json = this.toJSON();
        let result = new GetManyDocumentsResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyDocumentsResponseDto {
    data: Documents[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Documents implements IDocuments {
    id: number;
    documentOwner: DocumentsDocumentOwner;
    documentOwnerId: number;
    mimeType: string;
    fileName: string;
    relativePath: string;
    url: string;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DocumentsStatus;

    constructor(data?: IDocuments) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.documentOwner = _data["documentOwner"];
            this.documentOwnerId = _data["documentOwnerId"];
            this.mimeType = _data["mimeType"];
            this.fileName = _data["fileName"];
            this.relativePath = _data["relativePath"];
            this.url = _data["url"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Documents {
        data = typeof data === 'object' ? data : {};
        let result = new Documents();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["documentOwner"] = this.documentOwner;
        data["documentOwnerId"] = this.documentOwnerId;
        data["mimeType"] = this.mimeType;
        data["fileName"] = this.fileName;
        data["relativePath"] = this.relativePath;
        data["url"] = this.url;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): Documents {
        const json = this.toJSON();
        let result = new Documents();
        result.init(json);
        return result;
    }
}

export interface IDocuments {
    id: number;
    documentOwner: DocumentsDocumentOwner;
    documentOwnerId: number;
    mimeType: string;
    fileName: string;
    relativePath: string;
    url: string;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DocumentsStatus;
}

export class ProjectProgramData implements IProjectProgramData {
    id: number;
    projectProgram: ProjectProgramme;
    year: number;
    requestedDate: moment.Moment;
    deadline: moment.Moment;
    dataEntryDeadline: moment.Moment;
    dataEntryUser: User;
    projectProgress: string;
    projectStatus: ProjectStatus;
    dataRequestStatus: DataRequestStatus;
    requestedDataType1: string;
    requestedDataType2: string;
    dataRequestNote: string;
    noteDataEntry: string;
    noteDataApprover: string;
    noteDataCCS: string;
    chatURL: string;
    documents: Documents[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProjectProgramDataStatus;

    constructor(data?: IProjectProgramData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documents = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectProgram = _data["projectProgram"] ? ProjectProgramme.fromJS(_data["projectProgram"]) : <any>undefined;
            this.year = _data["year"];
            this.requestedDate = _data["requestedDate"] ? moment(_data["requestedDate"].toString()) : <any>undefined;
            this.deadline = _data["deadline"] ? moment(_data["deadline"].toString()) : <any>undefined;
            this.dataEntryDeadline = _data["dataEntryDeadline"] ? moment(_data["dataEntryDeadline"].toString()) : <any>undefined;
            this.dataEntryUser = _data["dataEntryUser"] ? User.fromJS(_data["dataEntryUser"]) : <any>undefined;
            this.projectProgress = _data["projectProgress"];
            this.projectStatus = _data["projectStatus"] ? ProjectStatus.fromJS(_data["projectStatus"]) : <any>undefined;
            this.dataRequestStatus = _data["dataRequestStatus"] ? DataRequestStatus.fromJS(_data["dataRequestStatus"]) : <any>undefined;
            this.requestedDataType1 = _data["requestedDataType1"];
            this.requestedDataType2 = _data["requestedDataType2"];
            this.dataRequestNote = _data["dataRequestNote"];
            this.noteDataEntry = _data["noteDataEntry"];
            this.noteDataApprover = _data["noteDataApprover"];
            this.noteDataCCS = _data["noteDataCCS"];
            this.chatURL = _data["chatURL"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents.push(Documents.fromJS(item));
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ProjectProgramData {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectProgramData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectProgram"] = this.projectProgram ? this.projectProgram.toJSON() : <any>undefined;
        data["year"] = this.year;
        data["requestedDate"] = this.requestedDate ? this.requestedDate.toISOString() : <any>undefined;
        data["deadline"] = this.deadline ? this.deadline.toISOString() : <any>undefined;
        data["dataEntryDeadline"] = this.dataEntryDeadline ? this.dataEntryDeadline.toISOString() : <any>undefined;
        data["dataEntryUser"] = this.dataEntryUser ? this.dataEntryUser.toJSON() : <any>undefined;
        data["projectProgress"] = this.projectProgress;
        data["projectStatus"] = this.projectStatus ? this.projectStatus.toJSON() : <any>undefined;
        data["dataRequestStatus"] = this.dataRequestStatus ? this.dataRequestStatus.toJSON() : <any>undefined;
        data["requestedDataType1"] = this.requestedDataType1;
        data["requestedDataType2"] = this.requestedDataType2;
        data["dataRequestNote"] = this.dataRequestNote;
        data["noteDataEntry"] = this.noteDataEntry;
        data["noteDataApprover"] = this.noteDataApprover;
        data["noteDataCCS"] = this.noteDataCCS;
        data["chatURL"] = this.chatURL;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ProjectProgramData {
        const json = this.toJSON();
        let result = new ProjectProgramData();
        result.init(json);
        return result;
    }
}

export interface IProjectProgramData {
    id: number;
    projectProgram: ProjectProgramme;
    year: number;
    requestedDate: moment.Moment;
    deadline: moment.Moment;
    dataEntryDeadline: moment.Moment;
    dataEntryUser: User;
    projectProgress: string;
    projectStatus: ProjectStatus;
    dataRequestStatus: DataRequestStatus;
    requestedDataType1: string;
    requestedDataType2: string;
    dataRequestNote: string;
    noteDataEntry: string;
    noteDataApprover: string;
    noteDataCCS: string;
    chatURL: string;
    documents: Documents[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProjectProgramDataStatus;
}

export class ProjectProgramme implements IProjectProgramme {
    id: number;
    name: string;
    description: string;
    isProject: boolean;
    proposedDateOfCommence: moment.Moment;
    projectDuration: number;
    scope: string;
    longitude: number;
    latitude: number;
    ghgEmissions: string;
    adaptationBenefits: string;
    isPublicProponent: boolean;
    partiesInvolved: string;
    publicDonor: boolean;
    privateDonor: boolean;
    internationalDonor: boolean;
    privatePublicDonor: boolean;
    ngoDonor: boolean;
    totalProjectCost: number;
    totalProjectCostCurrency: Currency;
    financingScheme: FinancingScheme;
    directSDBenefit: SDBenefit;
    indirectSDBenefit: SDBenefit;
    isNational: boolean;
    isSpecificLocation: boolean;
    province: Province;
    district: District;
    divisionalSecretariat: DivisionalSecretariat;
    projectStatus: ProjectStatus;
    climateChangeDataCategory: ClimateChangeDataCategory;
    sector: Sector;
    subSector: SubSector;
    projectType: ProjectType;
    dataSource: Institution;
    outcomes: string;
    projectProponents: string;
    implementingEntities: string;
    executingEntity: string;
    beneficiaries: string;
    deletedAt: moment.Moment;
    isPendingApprove: boolean;
    documentCount: number;
    publishDataCount: number;
    publishLatestUpdate: string;
    projectProgrammeData: ProjectProgramData[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProjectProgrammeStatus;

    constructor(data?: IProjectProgramme) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dataSource = new Institution();
            this.projectProgrammeData = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.isProject = _data["isProject"];
            this.proposedDateOfCommence = _data["proposedDateOfCommence"] ? moment(_data["proposedDateOfCommence"].toString()) : <any>undefined;
            this.projectDuration = _data["projectDuration"];
            this.scope = _data["scope"];
            this.longitude = _data["longitude"];
            this.latitude = _data["latitude"];
            this.ghgEmissions = _data["ghgEmissions"];
            this.adaptationBenefits = _data["adaptationBenefits"];
            this.isPublicProponent = _data["isPublicProponent"];
            this.partiesInvolved = _data["partiesInvolved"];
            this.publicDonor = _data["publicDonor"];
            this.privateDonor = _data["privateDonor"];
            this.internationalDonor = _data["internationalDonor"];
            this.privatePublicDonor = _data["privatePublicDonor"];
            this.ngoDonor = _data["ngoDonor"];
            this.totalProjectCost = _data["totalProjectCost"];
            this.totalProjectCostCurrency = _data["totalProjectCostCurrency"] ? Currency.fromJS(_data["totalProjectCostCurrency"]) : <any>undefined;
            this.financingScheme = _data["financingScheme"] ? FinancingScheme.fromJS(_data["financingScheme"]) : <any>undefined;
            this.directSDBenefit = _data["directSDBenefit"] ? SDBenefit.fromJS(_data["directSDBenefit"]) : <any>undefined;
            this.indirectSDBenefit = _data["indirectSDBenefit"] ? SDBenefit.fromJS(_data["indirectSDBenefit"]) : <any>undefined;
            this.isNational = _data["isNational"];
            this.isSpecificLocation = _data["isSpecificLocation"];
            this.province = _data["province"] ? Province.fromJS(_data["province"]) : <any>undefined;
            this.district = _data["district"] ? District.fromJS(_data["district"]) : <any>undefined;
            this.divisionalSecretariat = _data["divisionalSecretariat"] ? DivisionalSecretariat.fromJS(_data["divisionalSecretariat"]) : <any>undefined;
            this.projectStatus = _data["projectStatus"] ? ProjectStatus.fromJS(_data["projectStatus"]) : <any>undefined;
            this.climateChangeDataCategory = _data["climateChangeDataCategory"] ? ClimateChangeDataCategory.fromJS(_data["climateChangeDataCategory"]) : <any>undefined;
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : <any>undefined;
            this.subSector = _data["subSector"] ? SubSector.fromJS(_data["subSector"]) : <any>undefined;
            this.projectType = _data["projectType"] ? ProjectType.fromJS(_data["projectType"]) : <any>undefined;
            this.dataSource = _data["dataSource"] ? Institution.fromJS(_data["dataSource"]) : new Institution();
            this.outcomes = _data["outcomes"];
            this.projectProponents = _data["projectProponents"];
            this.implementingEntities = _data["implementingEntities"];
            this.executingEntity = _data["executingEntity"];
            this.beneficiaries = _data["beneficiaries"];
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.isPendingApprove = _data["isPendingApprove"];
            this.documentCount = _data["documentCount"];
            this.publishDataCount = _data["publishDataCount"];
            this.publishLatestUpdate = _data["publishLatestUpdate"];
            if (Array.isArray(_data["projectProgrammeData"])) {
                this.projectProgrammeData = [] as any;
                for (let item of _data["projectProgrammeData"])
                    this.projectProgrammeData.push(ProjectProgramData.fromJS(item));
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ProjectProgramme {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectProgramme();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["isProject"] = this.isProject;
        data["proposedDateOfCommence"] = this.proposedDateOfCommence ? this.proposedDateOfCommence.toISOString() : <any>undefined;
        data["projectDuration"] = this.projectDuration;
        data["scope"] = this.scope;
        data["longitude"] = this.longitude;
        data["latitude"] = this.latitude;
        data["ghgEmissions"] = this.ghgEmissions;
        data["adaptationBenefits"] = this.adaptationBenefits;
        data["isPublicProponent"] = this.isPublicProponent;
        data["partiesInvolved"] = this.partiesInvolved;
        data["publicDonor"] = this.publicDonor;
        data["privateDonor"] = this.privateDonor;
        data["internationalDonor"] = this.internationalDonor;
        data["privatePublicDonor"] = this.privatePublicDonor;
        data["ngoDonor"] = this.ngoDonor;
        data["totalProjectCost"] = this.totalProjectCost;
        data["totalProjectCostCurrency"] = this.totalProjectCostCurrency ? this.totalProjectCostCurrency.toJSON() : <any>undefined;
        data["financingScheme"] = this.financingScheme ? this.financingScheme.toJSON() : <any>undefined;
        data["directSDBenefit"] = this.directSDBenefit ? this.directSDBenefit.toJSON() : <any>undefined;
        data["indirectSDBenefit"] = this.indirectSDBenefit ? this.indirectSDBenefit.toJSON() : <any>undefined;
        data["isNational"] = this.isNational;
        data["isSpecificLocation"] = this.isSpecificLocation;
        data["province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["divisionalSecretariat"] = this.divisionalSecretariat ? this.divisionalSecretariat.toJSON() : <any>undefined;
        data["projectStatus"] = this.projectStatus ? this.projectStatus.toJSON() : <any>undefined;
        data["climateChangeDataCategory"] = this.climateChangeDataCategory ? this.climateChangeDataCategory.toJSON() : <any>undefined;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["subSector"] = this.subSector ? this.subSector.toJSON() : <any>undefined;
        data["projectType"] = this.projectType ? this.projectType.toJSON() : <any>undefined;
        data["dataSource"] = this.dataSource ? this.dataSource.toJSON() : <any>undefined;
        data["outcomes"] = this.outcomes;
        data["projectProponents"] = this.projectProponents;
        data["implementingEntities"] = this.implementingEntities;
        data["executingEntity"] = this.executingEntity;
        data["beneficiaries"] = this.beneficiaries;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["isPendingApprove"] = this.isPendingApprove;
        data["documentCount"] = this.documentCount;
        data["publishDataCount"] = this.publishDataCount;
        data["publishLatestUpdate"] = this.publishLatestUpdate;
        if (Array.isArray(this.projectProgrammeData)) {
            data["projectProgrammeData"] = [];
            for (let item of this.projectProgrammeData)
                data["projectProgrammeData"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ProjectProgramme {
        const json = this.toJSON();
        let result = new ProjectProgramme();
        result.init(json);
        return result;
    }
}

export interface IProjectProgramme {
    id: number;
    name: string;
    description: string;
    isProject: boolean;
    proposedDateOfCommence: moment.Moment;
    projectDuration: number;
    scope: string;
    longitude: number;
    latitude: number;
    ghgEmissions: string;
    adaptationBenefits: string;
    isPublicProponent: boolean;
    partiesInvolved: string;
    publicDonor: boolean;
    privateDonor: boolean;
    internationalDonor: boolean;
    privatePublicDonor: boolean;
    ngoDonor: boolean;
    totalProjectCost: number;
    totalProjectCostCurrency: Currency;
    financingScheme: FinancingScheme;
    directSDBenefit: SDBenefit;
    indirectSDBenefit: SDBenefit;
    isNational: boolean;
    isSpecificLocation: boolean;
    province: Province;
    district: District;
    divisionalSecretariat: DivisionalSecretariat;
    projectStatus: ProjectStatus;
    climateChangeDataCategory: ClimateChangeDataCategory;
    sector: Sector;
    subSector: SubSector;
    projectType: ProjectType;
    dataSource: Institution;
    outcomes: string;
    projectProponents: string;
    implementingEntities: string;
    executingEntity: string;
    beneficiaries: string;
    deletedAt: moment.Moment;
    isPendingApprove: boolean;
    documentCount: number;
    publishDataCount: number;
    publishLatestUpdate: string;
    projectProgrammeData: ProjectProgramData[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProjectProgrammeStatus;
}

export class CreateUserDto implements ICreateUserDto {
    userTypeId: number;
    firstName: string;
    lastName: string;
    username: string;
    password: string;
    email: string;
    title: string;
    institutionId: number;
    designation: string;
    telephone: string;
    mobile: string;
    nic: string;

    constructor(data?: ICreateUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userTypeId = _data["userTypeId"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.username = _data["username"];
            this.password = _data["password"];
            this.email = _data["email"];
            this.title = _data["title"];
            this.institutionId = _data["institutionId"];
            this.designation = _data["designation"];
            this.telephone = _data["telephone"];
            this.mobile = _data["mobile"];
            this.nic = _data["nic"];
        }
    }

    static fromJS(data: any): CreateUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userTypeId"] = this.userTypeId;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["username"] = this.username;
        data["password"] = this.password;
        data["email"] = this.email;
        data["title"] = this.title;
        data["institutionId"] = this.institutionId;
        data["designation"] = this.designation;
        data["telephone"] = this.telephone;
        data["mobile"] = this.mobile;
        data["nic"] = this.nic;
        return data; 
    }

    clone(): CreateUserDto {
        const json = this.toJSON();
        let result = new CreateUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateUserDto {
    userTypeId: number;
    firstName: string;
    lastName: string;
    username: string;
    password: string;
    email: string;
    title: string;
    institutionId: number;
    designation: string;
    telephone: string;
    mobile: string;
    nic: string;
}

export class RequestSummary implements IRequestSummary {
    name: string;
    count: number;
    sortOrder: number;

    constructor(data?: IRequestSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["Name"];
            this.count = _data["Count"];
            this.sortOrder = _data["SortOrder"];
        }
    }

    static fromJS(data: any): RequestSummary {
        data = typeof data === 'object' ? data : {};
        let result = new RequestSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Name"] = this.name;
        data["Count"] = this.count;
        data["SortOrder"] = this.sortOrder;
        return data; 
    }

    clone(): RequestSummary {
        const json = this.toJSON();
        let result = new RequestSummary();
        result.init(json);
        return result;
    }
}

export interface IRequestSummary {
    name: string;
    count: number;
    sortOrder: number;
}

export class RecentUpdateSummary implements IRecentUpdateSummary {
    status: string;
    parameterCount: number;
    projectCount: number;
    programmeCount: number;
    policieCount: number;

    constructor(data?: IRecentUpdateSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.status = _data["Status"];
            this.parameterCount = _data["ParameterCount"];
            this.projectCount = _data["ProjectCount"];
            this.programmeCount = _data["ProgrammeCount"];
            this.policieCount = _data["PolicieCount"];
        }
    }

    static fromJS(data: any): RecentUpdateSummary {
        data = typeof data === 'object' ? data : {};
        let result = new RecentUpdateSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["Status"] = this.status;
        data["ParameterCount"] = this.parameterCount;
        data["ProjectCount"] = this.projectCount;
        data["ProgrammeCount"] = this.programmeCount;
        data["PolicieCount"] = this.policieCount;
        return data; 
    }

    clone(): RecentUpdateSummary {
        const json = this.toJSON();
        let result = new RecentUpdateSummary();
        result.init(json);
        return result;
    }
}

export interface IRecentUpdateSummary {
    status: string;
    parameterCount: number;
    projectCount: number;
    programmeCount: number;
    policieCount: number;
}

export class RequestAssignSummary implements IRequestAssignSummary {
    user: User;
    userName: string;
    parameterCount: number;
    projectCount: number;
    programmeCount: number;
    policieCount: number;

    constructor(data?: IRequestAssignSummary) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.user = _data["User"] ? User.fromJS(_data["User"]) : new User();
            this.userName = _data["UserName"];
            this.parameterCount = _data["ParameterCount"];
            this.projectCount = _data["ProjectCount"];
            this.programmeCount = _data["ProgrammeCount"];
            this.policieCount = _data["PolicieCount"];
        }
    }

    static fromJS(data: any): RequestAssignSummary {
        data = typeof data === 'object' ? data : {};
        let result = new RequestAssignSummary();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["User"] = this.user ? this.user.toJSON() : <any>undefined;
        data["UserName"] = this.userName;
        data["ParameterCount"] = this.parameterCount;
        data["ProjectCount"] = this.projectCount;
        data["ProgrammeCount"] = this.programmeCount;
        data["PolicieCount"] = this.policieCount;
        return data; 
    }

    clone(): RequestAssignSummary {
        const json = this.toJSON();
        let result = new RequestAssignSummary();
        result.init(json);
        return result;
    }
}

export interface IRequestAssignSummary {
    user: User;
    userName: string;
    parameterCount: number;
    projectCount: number;
    programmeCount: number;
    policieCount: number;
}

export class CreateManyInstitutionDto implements ICreateManyInstitutionDto {
    bulk: Institution[];

    constructor(data?: ICreateManyInstitutionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Institution.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyInstitutionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyInstitutionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyInstitutionDto {
        const json = this.toJSON();
        let result = new CreateManyInstitutionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyInstitutionDto {
    bulk: Institution[];
}

export class CreateManyUserTypeDto implements ICreateManyUserTypeDto {
    bulk: UserType[];

    constructor(data?: ICreateManyUserTypeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(UserType.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUserTypeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUserTypeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyUserTypeDto {
        const json = this.toJSON();
        let result = new CreateManyUserTypeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUserTypeDto {
    bulk: UserType[];
}

export class DataUsageCategory implements IDataUsageCategory {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DataUsageCategoryStatus;

    constructor(data?: IDataUsageCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): DataUsageCategory {
        data = typeof data === 'object' ? data : {};
        let result = new DataUsageCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): DataUsageCategory {
        const json = this.toJSON();
        let result = new DataUsageCategory();
        result.init(json);
        return result;
    }
}

export interface IDataUsageCategory {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DataUsageCategoryStatus;
}

export class GetManyClimateImpactResponseDto implements IGetManyClimateImpactResponseDto {
    data: ClimateImpact[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyClimateImpactResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ClimateImpact.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyClimateImpactResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyClimateImpactResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyClimateImpactResponseDto {
        const json = this.toJSON();
        let result = new GetManyClimateImpactResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyClimateImpactResponseDto {
    data: ClimateImpact[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class ClimateImpact implements IClimateImpact {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ClimateImpactStatus;

    constructor(data?: IClimateImpact) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ClimateImpact {
        data = typeof data === 'object' ? data : {};
        let result = new ClimateImpact();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ClimateImpact {
        const json = this.toJSON();
        let result = new ClimateImpact();
        result.init(json);
        return result;
    }
}

export interface IClimateImpact {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ClimateImpactStatus;
}

export class Deadline implements IDeadline {
    addAmount: number;
    addType: string;
    notifyBefore: number;
    numberOfDays: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DeadlineStatus;

    constructor(data?: IDeadline) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.addAmount = _data["addAmount"];
            this.addType = _data["addType"];
            this.notifyBefore = _data["notifyBefore"];
            this.numberOfDays = _data["numberOfDays"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Deadline {
        data = typeof data === 'object' ? data : {};
        let result = new Deadline();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["addAmount"] = this.addAmount;
        data["addType"] = this.addType;
        data["notifyBefore"] = this.notifyBefore;
        data["numberOfDays"] = this.numberOfDays;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): Deadline {
        const json = this.toJSON();
        let result = new Deadline();
        result.init(json);
        return result;
    }
}

export interface IDeadline {
    addAmount: number;
    addType: string;
    notifyBefore: number;
    numberOfDays: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DeadlineStatus;
}

export class Frequency implements IFrequency {
    frequencyDetails: FrequencyDetail[];
    deadline: Deadline;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: FrequencyStatus;

    constructor(data?: IFrequency) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.frequencyDetails = [];
            this.deadline = new Deadline();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["frequencyDetails"])) {
                this.frequencyDetails = [] as any;
                for (let item of _data["frequencyDetails"])
                    this.frequencyDetails.push(FrequencyDetail.fromJS(item));
            }
            this.deadline = _data["deadline"] ? Deadline.fromJS(_data["deadline"]) : new Deadline();
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Frequency {
        data = typeof data === 'object' ? data : {};
        let result = new Frequency();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.frequencyDetails)) {
            data["frequencyDetails"] = [];
            for (let item of this.frequencyDetails)
                data["frequencyDetails"].push(item.toJSON());
        }
        data["deadline"] = this.deadline ? this.deadline.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): Frequency {
        const json = this.toJSON();
        let result = new Frequency();
        result.init(json);
        return result;
    }
}

export interface IFrequency {
    frequencyDetails: FrequencyDetail[];
    deadline: Deadline;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: FrequencyStatus;
}

export class FrequencyDetail implements IFrequencyDetail {
    frequency: Frequency;
    numberOfDate: number;
    numberofMonth: number;
    numberOfYear: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: FrequencyDetailStatus;

    constructor(data?: IFrequencyDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.frequency = new Frequency();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.frequency = _data["frequency"] ? Frequency.fromJS(_data["frequency"]) : new Frequency();
            this.numberOfDate = _data["numberOfDate"];
            this.numberofMonth = _data["numberofMonth"];
            this.numberOfYear = _data["numberOfYear"];
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): FrequencyDetail {
        data = typeof data === 'object' ? data : {};
        let result = new FrequencyDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["numberOfDate"] = this.numberOfDate;
        data["numberofMonth"] = this.numberofMonth;
        data["numberOfYear"] = this.numberOfYear;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): FrequencyDetail {
        const json = this.toJSON();
        let result = new FrequencyDetail();
        result.init(json);
        return result;
    }
}

export interface IFrequencyDetail {
    frequency: Frequency;
    numberOfDate: number;
    numberofMonth: number;
    numberOfYear: number;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: FrequencyDetailStatus;
}

export class GetManyDataRequestStatusHistoryResponseDto implements IGetManyDataRequestStatusHistoryResponseDto {
    data: DataRequestStatusHistory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyDataRequestStatusHistoryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(DataRequestStatusHistory.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyDataRequestStatusHistoryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyDataRequestStatusHistoryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyDataRequestStatusHistoryResponseDto {
        const json = this.toJSON();
        let result = new GetManyDataRequestStatusHistoryResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyDataRequestStatusHistoryResponseDto {
    data: DataRequestStatusHistory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyParameterLocationDataResponseDto implements IGetManyParameterLocationDataResponseDto {
    data: ParameterLocationData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyParameterLocationDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ParameterLocationData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyParameterLocationDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyParameterLocationDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyParameterLocationDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyParameterLocationDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyParameterLocationDataResponseDto {
    data: ParameterLocationData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyParameterLocationResponseDto implements IGetManyParameterLocationResponseDto {
    data: ParameterLocation[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyParameterLocationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ParameterLocation.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyParameterLocationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyParameterLocationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyParameterLocationResponseDto {
        const json = this.toJSON();
        let result = new GetManyParameterLocationResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyParameterLocationResponseDto {
    data: ParameterLocation[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyParameterResponseDto implements IGetManyParameterResponseDto {
    data: Parameter[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyParameterResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Parameter.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyParameterResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyParameterResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyParameterResponseDto {
        const json = this.toJSON();
        let result = new GetManyParameterResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyParameterResponseDto {
    data: Parameter[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class ParameterDataType implements IParameterDataType {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ParameterDataTypeStatus;

    constructor(data?: IParameterDataType) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ParameterDataType {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterDataType();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ParameterDataType {
        const json = this.toJSON();
        let result = new ParameterDataType();
        result.init(json);
        return result;
    }
}

export interface IParameterDataType {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ParameterDataTypeStatus;
}

export class GetManyUnitOfMeasureResponseDto implements IGetManyUnitOfMeasureResponseDto {
    data: UnitOfMeasure[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUnitOfMeasureResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(UnitOfMeasure.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUnitOfMeasureResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUnitOfMeasureResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyUnitOfMeasureResponseDto {
        const json = this.toJSON();
        let result = new GetManyUnitOfMeasureResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUnitOfMeasureResponseDto {
    data: UnitOfMeasure[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class GetManyUomConversionResponseDto implements IGetManyUomConversionResponseDto {
    data: UomConversion[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUomConversionResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(UomConversion.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUomConversionResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUomConversionResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyUomConversionResponseDto {
        const json = this.toJSON();
        let result = new GetManyUomConversionResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUomConversionResponseDto {
    data: UomConversion[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class UomConversion implements IUomConversion {
    id: number;
    unitOfMeasure: UnitOfMeasure;
    relatedUnitOfMeasure: UnitOfMeasure;
    conversionValue: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: UomConversionStatus;

    constructor(data?: IUomConversion) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.unitOfMeasure = _data["unitOfMeasure"] ? UnitOfMeasure.fromJS(_data["unitOfMeasure"]) : <any>undefined;
            this.relatedUnitOfMeasure = _data["relatedUnitOfMeasure"] ? UnitOfMeasure.fromJS(_data["relatedUnitOfMeasure"]) : <any>undefined;
            this.conversionValue = _data["conversionValue"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UomConversion {
        data = typeof data === 'object' ? data : {};
        let result = new UomConversion();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["unitOfMeasure"] = this.unitOfMeasure ? this.unitOfMeasure.toJSON() : <any>undefined;
        data["relatedUnitOfMeasure"] = this.relatedUnitOfMeasure ? this.relatedUnitOfMeasure.toJSON() : <any>undefined;
        data["conversionValue"] = this.conversionValue;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): UomConversion {
        const json = this.toJSON();
        let result = new UomConversion();
        result.init(json);
        return result;
    }
}

export interface IUomConversion {
    id: number;
    unitOfMeasure: UnitOfMeasure;
    relatedUnitOfMeasure: UnitOfMeasure;
    conversionValue: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: UomConversionStatus;
}

export class UnitOfMeasure implements IUnitOfMeasure {
    id: number;
    name: string;
    description: string;
    kindOfQuantity: string;
    print: string;
    isAMetricUnit: boolean;
    definitionValue: number;
    definitionValueText: string;
    definitionUnit: string;
    uomConversions: UomConversion[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: UnitOfMeasureStatus;

    constructor(data?: IUnitOfMeasure) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.kindOfQuantity = _data["kindOfQuantity"];
            this.print = _data["print"];
            this.isAMetricUnit = _data["isAMetricUnit"];
            this.definitionValue = _data["definitionValue"];
            this.definitionValueText = _data["definitionValueText"];
            this.definitionUnit = _data["definitionUnit"];
            if (Array.isArray(_data["UomConversions"])) {
                this.uomConversions = [] as any;
                for (let item of _data["UomConversions"])
                    this.uomConversions.push(UomConversion.fromJS(item));
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UnitOfMeasure {
        data = typeof data === 'object' ? data : {};
        let result = new UnitOfMeasure();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["kindOfQuantity"] = this.kindOfQuantity;
        data["print"] = this.print;
        data["isAMetricUnit"] = this.isAMetricUnit;
        data["definitionValue"] = this.definitionValue;
        data["definitionValueText"] = this.definitionValueText;
        data["definitionUnit"] = this.definitionUnit;
        if (Array.isArray(this.uomConversions)) {
            data["UomConversions"] = [];
            for (let item of this.uomConversions)
                data["UomConversions"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): UnitOfMeasure {
        const json = this.toJSON();
        let result = new UnitOfMeasure();
        result.init(json);
        return result;
    }
}

export interface IUnitOfMeasure {
    id: number;
    name: string;
    description: string;
    kindOfQuantity: string;
    print: string;
    isAMetricUnit: boolean;
    definitionValue: number;
    definitionValueText: string;
    definitionUnit: string;
    uomConversions: UomConversion[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: UnitOfMeasureStatus;
}

export class GetManyPolicyResponseDto implements IGetManyPolicyResponseDto {
    data: Policy[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyPolicyResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Policy.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyPolicyResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyPolicyResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyPolicyResponseDto {
        const json = this.toJSON();
        let result = new GetManyPolicyResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyPolicyResponseDto {
    data: Policy[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Policy implements IPolicy {
    id: number;
    name: string;
    description: string;
    climateChangeDataCategory: ClimateChangeDataCategory[];
    sector: Sector[];
    proposedDateOfCommence: moment.Moment;
    influence: PolicyInfluence;
    originalFormulationInstitution: string;
    formulationInstitution: Institution;
    isPendingApprove: boolean;
    deletedAt: moment.Moment;
    documentCount: number;
    publishDataCount: number;
    publishLatestUpdate: string;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: PolicyStatus;

    constructor(data?: IPolicy) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sector = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            if (Array.isArray(_data["climateChangeDataCategory"])) {
                this.climateChangeDataCategory = [] as any;
                for (let item of _data["climateChangeDataCategory"])
                    this.climateChangeDataCategory.push(ClimateChangeDataCategory.fromJS(item));
            }
            if (Array.isArray(_data["sector"])) {
                this.sector = [] as any;
                for (let item of _data["sector"])
                    this.sector.push(Sector.fromJS(item));
            }
            this.proposedDateOfCommence = _data["proposedDateOfCommence"] ? moment(_data["proposedDateOfCommence"].toString()) : <any>undefined;
            this.influence = _data["influence"];
            this.originalFormulationInstitution = _data["originalFormulationInstitution"];
            this.formulationInstitution = _data["formulationInstitution"] ? Institution.fromJS(_data["formulationInstitution"]) : <any>undefined;
            this.isPendingApprove = _data["isPendingApprove"];
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.documentCount = _data["documentCount"];
            this.publishDataCount = _data["publishDataCount"];
            this.publishLatestUpdate = _data["publishLatestUpdate"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Policy {
        data = typeof data === 'object' ? data : {};
        let result = new Policy();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        if (Array.isArray(this.climateChangeDataCategory)) {
            data["climateChangeDataCategory"] = [];
            for (let item of this.climateChangeDataCategory)
                data["climateChangeDataCategory"].push(item.toJSON());
        }
        if (Array.isArray(this.sector)) {
            data["sector"] = [];
            for (let item of this.sector)
                data["sector"].push(item.toJSON());
        }
        data["proposedDateOfCommence"] = this.proposedDateOfCommence ? this.proposedDateOfCommence.toISOString() : <any>undefined;
        data["influence"] = this.influence;
        data["originalFormulationInstitution"] = this.originalFormulationInstitution;
        data["formulationInstitution"] = this.formulationInstitution ? this.formulationInstitution.toJSON() : <any>undefined;
        data["isPendingApprove"] = this.isPendingApprove;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["documentCount"] = this.documentCount;
        data["publishDataCount"] = this.publishDataCount;
        data["publishLatestUpdate"] = this.publishLatestUpdate;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): Policy {
        const json = this.toJSON();
        let result = new Policy();
        result.init(json);
        return result;
    }
}

export interface IPolicy {
    id: number;
    name: string;
    description: string;
    climateChangeDataCategory: ClimateChangeDataCategory[];
    sector: Sector[];
    proposedDateOfCommence: moment.Moment;
    influence: PolicyInfluence;
    originalFormulationInstitution: string;
    formulationInstitution: Institution;
    isPendingApprove: boolean;
    deletedAt: moment.Moment;
    documentCount: number;
    publishDataCount: number;
    publishLatestUpdate: string;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: PolicyStatus;
}

export class Parameter implements IParameter {
    id: number;
    name: string;
    description: string;
    parameterDataType: ParameterDataType;
    unitOfMeasure: UnitOfMeasure;
    sampleParamterReading: string;
    minSampleValue: string;
    maxSampleValue: string;
    frequency: Frequency;
    deadline: Deadline;
    climateImpact: ClimateImpact;
    climateChangeDataCategory: ClimateChangeDataCategory;
    sector: Sector;
    institution: Institution;
    parameterLocation: ParameterLocation[];
    subSector: SubSector;
    isProject: boolean;
    project: ProjectProgramme;
    isProgramme: boolean;
    programme: ProjectProgramme;
    isPolicy: boolean;
    policy: Policy;
    isOther: boolean;
    isPublicData: boolean;
    commercialValue: number;
    dataCollectionLocation: ParameterDataCollectionLocation;
    dataCollectionGeography: ParameterDataCollectionGeography;
    locationName: string;
    deletedAt: moment.Moment;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ParameterStatus;

    constructor(data?: IParameter) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parameterDataType = new ParameterDataType();
            this.frequency = new Frequency();
            this.climateChangeDataCategory = new ClimateChangeDataCategory();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.parameterDataType = _data["parameterDataType"] ? ParameterDataType.fromJS(_data["parameterDataType"]) : new ParameterDataType();
            this.unitOfMeasure = _data["unitOfMeasure"] ? UnitOfMeasure.fromJS(_data["unitOfMeasure"]) : <any>undefined;
            this.sampleParamterReading = _data["sampleParamterReading"];
            this.minSampleValue = _data["minSampleValue"];
            this.maxSampleValue = _data["maxSampleValue"];
            this.frequency = _data["frequency"] ? Frequency.fromJS(_data["frequency"]) : new Frequency();
            this.deadline = _data["deadline"] ? Deadline.fromJS(_data["deadline"]) : <any>undefined;
            this.climateImpact = _data["climateImpact"] ? ClimateImpact.fromJS(_data["climateImpact"]) : <any>undefined;
            this.climateChangeDataCategory = _data["climateChangeDataCategory"] ? ClimateChangeDataCategory.fromJS(_data["climateChangeDataCategory"]) : new ClimateChangeDataCategory();
            this.sector = _data["sector"] ? Sector.fromJS(_data["sector"]) : <any>undefined;
            this.institution = _data["institution"] ? Institution.fromJS(_data["institution"]) : <any>undefined;
            if (Array.isArray(_data["parameterLocation"])) {
                this.parameterLocation = [] as any;
                for (let item of _data["parameterLocation"])
                    this.parameterLocation.push(ParameterLocation.fromJS(item));
            }
            this.subSector = _data["subSector"] ? SubSector.fromJS(_data["subSector"]) : <any>undefined;
            this.isProject = _data["isProject"];
            this.project = _data["project"] ? ProjectProgramme.fromJS(_data["project"]) : <any>undefined;
            this.isProgramme = _data["isProgramme"];
            this.programme = _data["programme"] ? ProjectProgramme.fromJS(_data["programme"]) : <any>undefined;
            this.isPolicy = _data["isPolicy"];
            this.policy = _data["policy"] ? Policy.fromJS(_data["policy"]) : <any>undefined;
            this.isOther = _data["isOther"];
            this.isPublicData = _data["isPublicData"];
            this.commercialValue = _data["commercialValue"];
            this.dataCollectionLocation = _data["dataCollectionLocation"];
            this.dataCollectionGeography = _data["dataCollectionGeography"];
            this.locationName = _data["locationName"];
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Parameter {
        data = typeof data === 'object' ? data : {};
        let result = new Parameter();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["parameterDataType"] = this.parameterDataType ? this.parameterDataType.toJSON() : <any>undefined;
        data["unitOfMeasure"] = this.unitOfMeasure ? this.unitOfMeasure.toJSON() : <any>undefined;
        data["sampleParamterReading"] = this.sampleParamterReading;
        data["minSampleValue"] = this.minSampleValue;
        data["maxSampleValue"] = this.maxSampleValue;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["deadline"] = this.deadline ? this.deadline.toJSON() : <any>undefined;
        data["climateImpact"] = this.climateImpact ? this.climateImpact.toJSON() : <any>undefined;
        data["climateChangeDataCategory"] = this.climateChangeDataCategory ? this.climateChangeDataCategory.toJSON() : <any>undefined;
        data["sector"] = this.sector ? this.sector.toJSON() : <any>undefined;
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        if (Array.isArray(this.parameterLocation)) {
            data["parameterLocation"] = [];
            for (let item of this.parameterLocation)
                data["parameterLocation"].push(item.toJSON());
        }
        data["subSector"] = this.subSector ? this.subSector.toJSON() : <any>undefined;
        data["isProject"] = this.isProject;
        data["project"] = this.project ? this.project.toJSON() : <any>undefined;
        data["isProgramme"] = this.isProgramme;
        data["programme"] = this.programme ? this.programme.toJSON() : <any>undefined;
        data["isPolicy"] = this.isPolicy;
        data["policy"] = this.policy ? this.policy.toJSON() : <any>undefined;
        data["isOther"] = this.isOther;
        data["isPublicData"] = this.isPublicData;
        data["commercialValue"] = this.commercialValue;
        data["dataCollectionLocation"] = this.dataCollectionLocation;
        data["dataCollectionGeography"] = this.dataCollectionGeography;
        data["locationName"] = this.locationName;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): Parameter {
        const json = this.toJSON();
        let result = new Parameter();
        result.init(json);
        return result;
    }
}

export interface IParameter {
    id: number;
    name: string;
    description: string;
    parameterDataType: ParameterDataType;
    unitOfMeasure: UnitOfMeasure;
    sampleParamterReading: string;
    minSampleValue: string;
    maxSampleValue: string;
    frequency: Frequency;
    deadline: Deadline;
    climateImpact: ClimateImpact;
    climateChangeDataCategory: ClimateChangeDataCategory;
    sector: Sector;
    institution: Institution;
    parameterLocation: ParameterLocation[];
    subSector: SubSector;
    isProject: boolean;
    project: ProjectProgramme;
    isProgramme: boolean;
    programme: ProjectProgramme;
    isPolicy: boolean;
    policy: Policy;
    isOther: boolean;
    isPublicData: boolean;
    commercialValue: number;
    dataCollectionLocation: ParameterDataCollectionLocation;
    dataCollectionGeography: ParameterDataCollectionGeography;
    locationName: string;
    deletedAt: moment.Moment;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ParameterStatus;
}

export class ParameterLocation implements IParameterLocation {
    id: number;
    parameterLocation: ParameterLocationData[];
    parameter: Parameter;
    isNational: boolean;
    isSpecificLocation: boolean;
    province: Province;
    district: District;
    divisionalSecretariat: DivisionalSecretariat;
    dataSource: Institution;
    deletedAt: moment.Moment;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ParameterLocationStatus;

    constructor(data?: IParameterLocation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parameterLocation = [];
            this.parameter = new Parameter();
            this.dataSource = new Institution();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            if (Array.isArray(_data["parameterLocation"])) {
                this.parameterLocation = [] as any;
                for (let item of _data["parameterLocation"])
                    this.parameterLocation.push(ParameterLocationData.fromJS(item));
            }
            this.parameter = _data["parameter"] ? Parameter.fromJS(_data["parameter"]) : new Parameter();
            this.isNational = _data["isNational"];
            this.isSpecificLocation = _data["isSpecificLocation"];
            this.province = _data["province"] ? Province.fromJS(_data["province"]) : <any>undefined;
            this.district = _data["district"] ? District.fromJS(_data["district"]) : <any>undefined;
            this.divisionalSecretariat = _data["divisionalSecretariat"] ? DivisionalSecretariat.fromJS(_data["divisionalSecretariat"]) : <any>undefined;
            this.dataSource = _data["dataSource"] ? Institution.fromJS(_data["dataSource"]) : new Institution();
            this.deletedAt = _data["deletedAt"] ? moment(_data["deletedAt"].toString()) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ParameterLocation {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterLocation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        if (Array.isArray(this.parameterLocation)) {
            data["parameterLocation"] = [];
            for (let item of this.parameterLocation)
                data["parameterLocation"].push(item.toJSON());
        }
        data["parameter"] = this.parameter ? this.parameter.toJSON() : <any>undefined;
        data["isNational"] = this.isNational;
        data["isSpecificLocation"] = this.isSpecificLocation;
        data["province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["divisionalSecretariat"] = this.divisionalSecretariat ? this.divisionalSecretariat.toJSON() : <any>undefined;
        data["dataSource"] = this.dataSource ? this.dataSource.toJSON() : <any>undefined;
        data["deletedAt"] = this.deletedAt ? this.deletedAt.toISOString() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ParameterLocation {
        const json = this.toJSON();
        let result = new ParameterLocation();
        result.init(json);
        return result;
    }
}

export interface IParameterLocation {
    id: number;
    parameterLocation: ParameterLocationData[];
    parameter: Parameter;
    isNational: boolean;
    isSpecificLocation: boolean;
    province: Province;
    district: District;
    divisionalSecretariat: DivisionalSecretariat;
    dataSource: Institution;
    deletedAt: moment.Moment;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ParameterLocationStatus;
}

export class ParameterLocationData implements IParameterLocationData {
    id: number;
    parameterLocation: ParameterLocation;
    parameterId: number;
    requestedDate: moment.Moment;
    requestdYear: number;
    frequency: Frequency;
    frequencyDetail: FrequencyDetail;
    startDate: moment.Moment;
    endDate: moment.Moment;
    deadline: moment.Moment;
    reasonforExceedRange: string;
    dataEnteryDeadline: moment.Moment;
    value: string;
    conversionUnitOfMeasurevalue: string;
    unitOfMeasureDataEntry: UnitOfMeasure;
    conversionUOMeDataEntry: UomConversion;
    dataEntryUser: User;
    dataRequestStatus: DataRequestStatus;
    dataEntryDeadLine: moment.Moment;
    valueInParameterStandard: string;
    unitOfMeasureInParameterStandard: UnitOfMeasure;
    dataRequestNote: string;
    notedataEntry: string;
    notedataApprover: string;
    notedataCCS: string;
    chatURL: string;
    contentComment: string;
    contentCommentRequired: boolean;
    comment: string;
    historicalMinimum: number;
    historicalMaximum: number;
    dataEntryValue: number;
    isValiddataEntryValue: boolean;
    parameter: Parameter;
    validTimeDuration: string;
    uomConversions: UomConversion[];
    documents: Documents[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ParameterLocationDataStatus;

    constructor(data?: IParameterLocationData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parameterLocation = new ParameterLocation();
            this.parameter = new Parameter();
            this.documents = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.parameterLocation = _data["parameterLocation"] ? ParameterLocation.fromJS(_data["parameterLocation"]) : new ParameterLocation();
            this.parameterId = _data["parameterId"];
            this.requestedDate = _data["requestedDate"] ? moment(_data["requestedDate"].toString()) : <any>undefined;
            this.requestdYear = _data["requestdYear"];
            this.frequency = _data["frequency"] ? Frequency.fromJS(_data["frequency"]) : <any>undefined;
            this.frequencyDetail = _data["frequencyDetail"] ? FrequencyDetail.fromJS(_data["frequencyDetail"]) : <any>undefined;
            this.startDate = _data["startDate"] ? moment(_data["startDate"].toString()) : <any>undefined;
            this.endDate = _data["endDate"] ? moment(_data["endDate"].toString()) : <any>undefined;
            this.deadline = _data["deadline"] ? moment(_data["deadline"].toString()) : <any>undefined;
            this.reasonforExceedRange = _data["reasonforExceedRange"];
            this.dataEnteryDeadline = _data["dataEnteryDeadline"] ? moment(_data["dataEnteryDeadline"].toString()) : <any>undefined;
            this.value = _data["value"];
            this.conversionUnitOfMeasurevalue = _data["conversionUnitOfMeasurevalue"];
            this.unitOfMeasureDataEntry = _data["unitOfMeasureDataEntry"] ? UnitOfMeasure.fromJS(_data["unitOfMeasureDataEntry"]) : <any>undefined;
            this.conversionUOMeDataEntry = _data["conversionUOMeDataEntry"] ? UomConversion.fromJS(_data["conversionUOMeDataEntry"]) : <any>undefined;
            this.dataEntryUser = _data["dataEntryUser"] ? User.fromJS(_data["dataEntryUser"]) : <any>undefined;
            this.dataRequestStatus = _data["dataRequestStatus"] ? DataRequestStatus.fromJS(_data["dataRequestStatus"]) : <any>undefined;
            this.dataEntryDeadLine = _data["dataEntryDeadLine"] ? moment(_data["dataEntryDeadLine"].toString()) : <any>undefined;
            this.valueInParameterStandard = _data["valueInParameterStandard"];
            this.unitOfMeasureInParameterStandard = _data["unitOfMeasureInParameterStandard"] ? UnitOfMeasure.fromJS(_data["unitOfMeasureInParameterStandard"]) : <any>undefined;
            this.dataRequestNote = _data["dataRequestNote"];
            this.notedataEntry = _data["notedataEntry"];
            this.notedataApprover = _data["notedataApprover"];
            this.notedataCCS = _data["notedataCCS"];
            this.chatURL = _data["chatURL"];
            this.contentComment = _data["contentComment"];
            this.contentCommentRequired = _data["contentCommentRequired"];
            this.comment = _data["comment"];
            this.historicalMinimum = _data["historicalMinimum"];
            this.historicalMaximum = _data["historicalMaximum"];
            this.dataEntryValue = _data["dataEntryValue"];
            this.isValiddataEntryValue = _data["isValiddataEntryValue"];
            this.parameter = _data["parameter"] ? Parameter.fromJS(_data["parameter"]) : new Parameter();
            this.validTimeDuration = _data["validTimeDuration"];
            if (Array.isArray(_data["uomConversions"])) {
                this.uomConversions = [] as any;
                for (let item of _data["uomConversions"])
                    this.uomConversions.push(UomConversion.fromJS(item));
            }
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents.push(Documents.fromJS(item));
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ParameterLocationData {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterLocationData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["parameterLocation"] = this.parameterLocation ? this.parameterLocation.toJSON() : <any>undefined;
        data["parameterId"] = this.parameterId;
        data["requestedDate"] = this.requestedDate ? this.requestedDate.toISOString() : <any>undefined;
        data["requestdYear"] = this.requestdYear;
        data["frequency"] = this.frequency ? this.frequency.toJSON() : <any>undefined;
        data["frequencyDetail"] = this.frequencyDetail ? this.frequencyDetail.toJSON() : <any>undefined;
        data["startDate"] = this.startDate ? this.startDate.toISOString() : <any>undefined;
        data["endDate"] = this.endDate ? this.endDate.toISOString() : <any>undefined;
        data["deadline"] = this.deadline ? this.deadline.toISOString() : <any>undefined;
        data["reasonforExceedRange"] = this.reasonforExceedRange;
        data["dataEnteryDeadline"] = this.dataEnteryDeadline ? this.dataEnteryDeadline.toISOString() : <any>undefined;
        data["value"] = this.value;
        data["conversionUnitOfMeasurevalue"] = this.conversionUnitOfMeasurevalue;
        data["unitOfMeasureDataEntry"] = this.unitOfMeasureDataEntry ? this.unitOfMeasureDataEntry.toJSON() : <any>undefined;
        data["conversionUOMeDataEntry"] = this.conversionUOMeDataEntry ? this.conversionUOMeDataEntry.toJSON() : <any>undefined;
        data["dataEntryUser"] = this.dataEntryUser ? this.dataEntryUser.toJSON() : <any>undefined;
        data["dataRequestStatus"] = this.dataRequestStatus ? this.dataRequestStatus.toJSON() : <any>undefined;
        data["dataEntryDeadLine"] = this.dataEntryDeadLine ? this.dataEntryDeadLine.toISOString() : <any>undefined;
        data["valueInParameterStandard"] = this.valueInParameterStandard;
        data["unitOfMeasureInParameterStandard"] = this.unitOfMeasureInParameterStandard ? this.unitOfMeasureInParameterStandard.toJSON() : <any>undefined;
        data["dataRequestNote"] = this.dataRequestNote;
        data["notedataEntry"] = this.notedataEntry;
        data["notedataApprover"] = this.notedataApprover;
        data["notedataCCS"] = this.notedataCCS;
        data["chatURL"] = this.chatURL;
        data["contentComment"] = this.contentComment;
        data["contentCommentRequired"] = this.contentCommentRequired;
        data["comment"] = this.comment;
        data["historicalMinimum"] = this.historicalMinimum;
        data["historicalMaximum"] = this.historicalMaximum;
        data["dataEntryValue"] = this.dataEntryValue;
        data["isValiddataEntryValue"] = this.isValiddataEntryValue;
        data["parameter"] = this.parameter ? this.parameter.toJSON() : <any>undefined;
        data["validTimeDuration"] = this.validTimeDuration;
        if (Array.isArray(this.uomConversions)) {
            data["uomConversions"] = [];
            for (let item of this.uomConversions)
                data["uomConversions"].push(item.toJSON());
        }
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ParameterLocationData {
        const json = this.toJSON();
        let result = new ParameterLocationData();
        result.init(json);
        return result;
    }
}

export interface IParameterLocationData {
    id: number;
    parameterLocation: ParameterLocation;
    parameterId: number;
    requestedDate: moment.Moment;
    requestdYear: number;
    frequency: Frequency;
    frequencyDetail: FrequencyDetail;
    startDate: moment.Moment;
    endDate: moment.Moment;
    deadline: moment.Moment;
    reasonforExceedRange: string;
    dataEnteryDeadline: moment.Moment;
    value: string;
    conversionUnitOfMeasurevalue: string;
    unitOfMeasureDataEntry: UnitOfMeasure;
    conversionUOMeDataEntry: UomConversion;
    dataEntryUser: User;
    dataRequestStatus: DataRequestStatus;
    dataEntryDeadLine: moment.Moment;
    valueInParameterStandard: string;
    unitOfMeasureInParameterStandard: UnitOfMeasure;
    dataRequestNote: string;
    notedataEntry: string;
    notedataApprover: string;
    notedataCCS: string;
    chatURL: string;
    contentComment: string;
    contentCommentRequired: boolean;
    comment: string;
    historicalMinimum: number;
    historicalMaximum: number;
    dataEntryValue: number;
    isValiddataEntryValue: boolean;
    parameter: Parameter;
    validTimeDuration: string;
    uomConversions: UomConversion[];
    documents: Documents[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ParameterLocationDataStatus;
}

export class GetManyPolicyDataResponseDto implements IGetManyPolicyDataResponseDto {
    data: PolicyData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyPolicyDataResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(PolicyData.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyPolicyDataResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyPolicyDataResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyPolicyDataResponseDto {
        const json = this.toJSON();
        let result = new GetManyPolicyDataResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyPolicyDataResponseDto {
    data: PolicyData[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class PolicyData implements IPolicyData {
    id: number;
    policy: Policy;
    institutionId: number;
    year: number;
    requestedDate: moment.Moment;
    deadline: moment.Moment;
    dataEntryDeadline: moment.Moment;
    dataEntryUser: User;
    amendments: string;
    dataRequestStatus: DataRequestStatus;
    dataRequestNote: string;
    noteDataEntry: string;
    noteDataApprover: string;
    noteDataCCS: string;
    chatURL: string;
    documents: Documents[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: PolicyDataStatus;

    constructor(data?: IPolicyData) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.documents = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.policy = _data["policy"] ? Policy.fromJS(_data["policy"]) : <any>undefined;
            this.institutionId = _data["institutionId"];
            this.year = _data["year"];
            this.requestedDate = _data["requestedDate"] ? moment(_data["requestedDate"].toString()) : <any>undefined;
            this.deadline = _data["deadline"] ? moment(_data["deadline"].toString()) : <any>undefined;
            this.dataEntryDeadline = _data["dataEntryDeadline"] ? moment(_data["dataEntryDeadline"].toString()) : <any>undefined;
            this.dataEntryUser = _data["dataEntryUser"] ? User.fromJS(_data["dataEntryUser"]) : <any>undefined;
            this.amendments = _data["amendments"];
            this.dataRequestStatus = _data["dataRequestStatus"] ? DataRequestStatus.fromJS(_data["dataRequestStatus"]) : <any>undefined;
            this.dataRequestNote = _data["dataRequestNote"];
            this.noteDataEntry = _data["noteDataEntry"];
            this.noteDataApprover = _data["noteDataApprover"];
            this.noteDataCCS = _data["noteDataCCS"];
            this.chatURL = _data["chatURL"];
            if (Array.isArray(_data["documents"])) {
                this.documents = [] as any;
                for (let item of _data["documents"])
                    this.documents.push(Documents.fromJS(item));
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): PolicyData {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyData();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["policy"] = this.policy ? this.policy.toJSON() : <any>undefined;
        data["institutionId"] = this.institutionId;
        data["year"] = this.year;
        data["requestedDate"] = this.requestedDate ? this.requestedDate.toISOString() : <any>undefined;
        data["deadline"] = this.deadline ? this.deadline.toISOString() : <any>undefined;
        data["dataEntryDeadline"] = this.dataEntryDeadline ? this.dataEntryDeadline.toISOString() : <any>undefined;
        data["dataEntryUser"] = this.dataEntryUser ? this.dataEntryUser.toJSON() : <any>undefined;
        data["amendments"] = this.amendments;
        data["dataRequestStatus"] = this.dataRequestStatus ? this.dataRequestStatus.toJSON() : <any>undefined;
        data["dataRequestNote"] = this.dataRequestNote;
        data["noteDataEntry"] = this.noteDataEntry;
        data["noteDataApprover"] = this.noteDataApprover;
        data["noteDataCCS"] = this.noteDataCCS;
        data["chatURL"] = this.chatURL;
        if (Array.isArray(this.documents)) {
            data["documents"] = [];
            for (let item of this.documents)
                data["documents"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): PolicyData {
        const json = this.toJSON();
        let result = new PolicyData();
        result.init(json);
        return result;
    }
}

export interface IPolicyData {
    id: number;
    policy: Policy;
    institutionId: number;
    year: number;
    requestedDate: moment.Moment;
    deadline: moment.Moment;
    dataEntryDeadline: moment.Moment;
    dataEntryUser: User;
    amendments: string;
    dataRequestStatus: DataRequestStatus;
    dataRequestNote: string;
    noteDataEntry: string;
    noteDataApprover: string;
    noteDataCCS: string;
    chatURL: string;
    documents: Documents[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: PolicyDataStatus;
}

export class DataRequestStatusHistory implements IDataRequestStatusHistory {
    comment: string;
    userId: number;
    userName: string;
    statusId: number;
    statusText: string;
    parameterId: number;
    parameterLocationData: ParameterLocationData;
    projectProgramData: ProjectProgramData;
    policyData: PolicyData;
    itemDetails: string;
    user: User;
    institution: Institution;
    province: Province;
    district: District;
    divisionalSecretariat: DivisionalSecretariat;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DataRequestStatusHistoryStatus;

    constructor(data?: IDataRequestStatusHistory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.user = new User();
            this.institution = new Institution();
            this.province = new Province();
            this.district = new District();
            this.divisionalSecretariat = new DivisionalSecretariat();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.comment = _data["comment"];
            this.userId = _data["userId"];
            this.userName = _data["userName"];
            this.statusId = _data["statusId"];
            this.statusText = _data["statusText"];
            this.parameterId = _data["parameterId"];
            this.parameterLocationData = _data["parameterLocationData"] ? ParameterLocationData.fromJS(_data["parameterLocationData"]) : <any>undefined;
            this.projectProgramData = _data["projectProgramData"] ? ProjectProgramData.fromJS(_data["projectProgramData"]) : <any>undefined;
            this.policyData = _data["policyData"] ? PolicyData.fromJS(_data["policyData"]) : <any>undefined;
            this.itemDetails = _data["itemDetails"];
            this.user = _data["user"] ? User.fromJS(_data["user"]) : new User();
            this.institution = _data["institution"] ? Institution.fromJS(_data["institution"]) : new Institution();
            this.province = _data["province"] ? Province.fromJS(_data["province"]) : new Province();
            this.district = _data["district"] ? District.fromJS(_data["district"]) : new District();
            this.divisionalSecretariat = _data["divisionalSecretariat"] ? DivisionalSecretariat.fromJS(_data["divisionalSecretariat"]) : new DivisionalSecretariat();
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): DataRequestStatusHistory {
        data = typeof data === 'object' ? data : {};
        let result = new DataRequestStatusHistory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["comment"] = this.comment;
        data["userId"] = this.userId;
        data["userName"] = this.userName;
        data["statusId"] = this.statusId;
        data["statusText"] = this.statusText;
        data["parameterId"] = this.parameterId;
        data["parameterLocationData"] = this.parameterLocationData ? this.parameterLocationData.toJSON() : <any>undefined;
        data["projectProgramData"] = this.projectProgramData ? this.projectProgramData.toJSON() : <any>undefined;
        data["policyData"] = this.policyData ? this.policyData.toJSON() : <any>undefined;
        data["itemDetails"] = this.itemDetails;
        data["user"] = this.user ? this.user.toJSON() : <any>undefined;
        data["institution"] = this.institution ? this.institution.toJSON() : <any>undefined;
        data["province"] = this.province ? this.province.toJSON() : <any>undefined;
        data["district"] = this.district ? this.district.toJSON() : <any>undefined;
        data["divisionalSecretariat"] = this.divisionalSecretariat ? this.divisionalSecretariat.toJSON() : <any>undefined;
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): DataRequestStatusHistory {
        const json = this.toJSON();
        let result = new DataRequestStatusHistory();
        result.init(json);
        return result;
    }
}

export interface IDataRequestStatusHistory {
    comment: string;
    userId: number;
    userName: string;
    statusId: number;
    statusText: string;
    parameterId: number;
    parameterLocationData: ParameterLocationData;
    projectProgramData: ProjectProgramData;
    policyData: PolicyData;
    itemDetails: string;
    user: User;
    institution: Institution;
    province: Province;
    district: District;
    divisionalSecretariat: DivisionalSecretariat;
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: DataRequestStatusHistoryStatus;
}

export class GetManyMitigationResponseDto implements IGetManyMitigationResponseDto {
    data: Mitigation[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyMitigationResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(Mitigation.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyMitigationResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyMitigationResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyMitigationResponseDto {
        const json = this.toJSON();
        let result = new GetManyMitigationResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyMitigationResponseDto {
    data: Mitigation[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class Mitigation implements IMitigation {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: MitigationStatus;

    constructor(data?: IMitigation) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): Mitigation {
        data = typeof data === 'object' ? data : {};
        let result = new Mitigation();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): Mitigation {
        const json = this.toJSON();
        let result = new Mitigation();
        result.init(json);
        return result;
    }
}

export interface IMitigation {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: MitigationStatus;
}

export class CreateManyMitigationDto implements ICreateManyMitigationDto {
    bulk: Mitigation[];

    constructor(data?: ICreateManyMitigationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Mitigation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyMitigationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyMitigationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyMitigationDto {
        const json = this.toJSON();
        let result = new CreateManyMitigationDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyMitigationDto {
    bulk: Mitigation[];
}

export class CreateManyUomConversionDto implements ICreateManyUomConversionDto {
    bulk: UomConversion[];

    constructor(data?: ICreateManyUomConversionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(UomConversion.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUomConversionDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUomConversionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyUomConversionDto {
        const json = this.toJSON();
        let result = new CreateManyUomConversionDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUomConversionDto {
    bulk: UomConversion[];
}

export class CreateManyClimateImpactDto implements ICreateManyClimateImpactDto {
    bulk: ClimateImpact[];

    constructor(data?: ICreateManyClimateImpactDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ClimateImpact.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyClimateImpactDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyClimateImpactDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyClimateImpactDto {
        const json = this.toJSON();
        let result = new CreateManyClimateImpactDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyClimateImpactDto {
    bulk: ClimateImpact[];
}

export class CreateManyUserDto implements ICreateManyUserDto {
    bulk: User[];

    constructor(data?: ICreateManyUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(User.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUserDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyUserDto {
        const json = this.toJSON();
        let result = new CreateManyUserDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUserDto {
    bulk: User[];
}

export class CreateManyParameterDto implements ICreateManyParameterDto {
    bulk: Parameter[];

    constructor(data?: ICreateManyParameterDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Parameter.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyParameterDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyParameterDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyParameterDto {
        const json = this.toJSON();
        let result = new CreateManyParameterDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyParameterDto {
    bulk: Parameter[];
}

export class CreateManyUnitOfMeasureDto implements ICreateManyUnitOfMeasureDto {
    bulk: UnitOfMeasure[];

    constructor(data?: ICreateManyUnitOfMeasureDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(UnitOfMeasure.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUnitOfMeasureDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUnitOfMeasureDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyUnitOfMeasureDto {
        const json = this.toJSON();
        let result = new CreateManyUnitOfMeasureDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUnitOfMeasureDto {
    bulk: UnitOfMeasure[];
}

export class CreateManyClimateChangeDataCategoryDto implements ICreateManyClimateChangeDataCategoryDto {
    bulk: ClimateChangeDataCategory[];

    constructor(data?: ICreateManyClimateChangeDataCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ClimateChangeDataCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyClimateChangeDataCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyClimateChangeDataCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyClimateChangeDataCategoryDto {
        const json = this.toJSON();
        let result = new CreateManyClimateChangeDataCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyClimateChangeDataCategoryDto {
    bulk: ClimateChangeDataCategory[];
}

export class CreateManySectorDto implements ICreateManySectorDto {
    bulk: Sector[];

    constructor(data?: ICreateManySectorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Sector.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManySectorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManySectorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManySectorDto {
        const json = this.toJSON();
        let result = new CreateManySectorDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManySectorDto {
    bulk: Sector[];
}

export class CreateManySubSectorDto implements ICreateManySubSectorDto {
    bulk: SubSector[];

    constructor(data?: ICreateManySubSectorDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(SubSector.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManySubSectorDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManySubSectorDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManySubSectorDto {
        const json = this.toJSON();
        let result = new CreateManySubSectorDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManySubSectorDto {
    bulk: SubSector[];
}

export class GetManySectorMOEResponseDto implements IGetManySectorMOEResponseDto {
    data: SectorMOE[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManySectorMOEResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(SectorMOE.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManySectorMOEResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManySectorMOEResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManySectorMOEResponseDto {
        const json = this.toJSON();
        let result = new GetManySectorMOEResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManySectorMOEResponseDto {
    data: SectorMOE[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class SectorMOE implements ISectorMOE {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: SectorMOEStatus;

    constructor(data?: ISectorMOE) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.sortOrder = _data["sortOrder"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): SectorMOE {
        data = typeof data === 'object' ? data : {};
        let result = new SectorMOE();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["name"] = this.name;
        data["description"] = this.description;
        data["sortOrder"] = this.sortOrder;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): SectorMOE {
        const json = this.toJSON();
        let result = new SectorMOE();
        result.init(json);
        return result;
    }
}

export interface ISectorMOE {
    id: number;
    name: string;
    description: string;
    sortOrder: number;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: SectorMOEStatus;
}

export class CreateManySectorMOEDto implements ICreateManySectorMOEDto {
    bulk: SectorMOE[];

    constructor(data?: ICreateManySectorMOEDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(SectorMOE.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManySectorMOEDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManySectorMOEDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManySectorMOEDto {
        const json = this.toJSON();
        let result = new CreateManySectorMOEDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManySectorMOEDto {
    bulk: SectorMOE[];
}

export class ParameterLocationUpdateRequestDto implements IParameterLocationUpdateRequestDto {
    parameterId: number;
    parameterLocations: ParameterLocation[];
    locationName: string;

    constructor(data?: IParameterLocationUpdateRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parameterLocations = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parameterId = _data["parameterId"];
            if (Array.isArray(_data["parameterLocations"])) {
                this.parameterLocations = [] as any;
                for (let item of _data["parameterLocations"])
                    this.parameterLocations.push(ParameterLocation.fromJS(item));
            }
            this.locationName = _data["locationName"];
        }
    }

    static fromJS(data: any): ParameterLocationUpdateRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new ParameterLocationUpdateRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parameterId"] = this.parameterId;
        if (Array.isArray(this.parameterLocations)) {
            data["parameterLocations"] = [];
            for (let item of this.parameterLocations)
                data["parameterLocations"].push(item.toJSON());
        }
        data["locationName"] = this.locationName;
        return data; 
    }

    clone(): ParameterLocationUpdateRequestDto {
        const json = this.toJSON();
        let result = new ParameterLocationUpdateRequestDto();
        result.init(json);
        return result;
    }
}

export interface IParameterLocationUpdateRequestDto {
    parameterId: number;
    parameterLocations: ParameterLocation[];
    locationName: string;
}

export class CreateManyParameterLocationDto implements ICreateManyParameterLocationDto {
    bulk: ParameterLocation[];

    constructor(data?: ICreateManyParameterLocationDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ParameterLocation.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyParameterLocationDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyParameterLocationDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyParameterLocationDto {
        const json = this.toJSON();
        let result = new CreateManyParameterLocationDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyParameterLocationDto {
    bulk: ParameterLocation[];
}

export class CreateManyParameterLocationDataDto implements ICreateManyParameterLocationDataDto {
    bulk: ParameterLocationData[];

    constructor(data?: ICreateManyParameterLocationDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ParameterLocationData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyParameterLocationDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyParameterLocationDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyParameterLocationDataDto {
        const json = this.toJSON();
        let result = new CreateManyParameterLocationDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyParameterLocationDataDto {
    bulk: ParameterLocationData[];
}

export class CreateManyDataRequestStatusHistoryDto implements ICreateManyDataRequestStatusHistoryDto {
    bulk: DataRequestStatusHistory[];

    constructor(data?: ICreateManyDataRequestStatusHistoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(DataRequestStatusHistory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyDataRequestStatusHistoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyDataRequestStatusHistoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyDataRequestStatusHistoryDto {
        const json = this.toJSON();
        let result = new CreateManyDataRequestStatusHistoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyDataRequestStatusHistoryDto {
    bulk: DataRequestStatusHistory[];
}

export class PurchaseParameterDataRecordDto implements IPurchaseParameterDataRecordDto {
    parameterDataId: number;
    parameterId: number;
    name: string;
    description: string;
    location: any;
    dataProvider: string;
    value: string;
    unit: string;
    validTimeDuration: string;
    dataValidFrom: moment.Moment;
    dataValidTo: moment.Moment;
    isPublicData: boolean;
    commercialValue: number;
    frequency: string;
    isInActiveCart: boolean;
    isAlreadyPurchased: boolean;
    parameterDataType: ParameterDataType;
    contentComment: string;
    documentList: any[];

    constructor(data?: IPurchaseParameterDataRecordDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parameterDataType = new ParameterDataType();
            this.documentList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parameterDataId = _data["parameterDataId"];
            this.parameterId = _data["parameterId"];
            this.name = _data["name"];
            this.description = _data["description"];
            this.location = _data["location"];
            this.dataProvider = _data["dataProvider"];
            this.value = _data["value"];
            this.unit = _data["unit"];
            this.validTimeDuration = _data["validTimeDuration"];
            this.dataValidFrom = _data["dataValidFrom"] ? moment(_data["dataValidFrom"].toString()) : <any>undefined;
            this.dataValidTo = _data["dataValidTo"] ? moment(_data["dataValidTo"].toString()) : <any>undefined;
            this.isPublicData = _data["isPublicData"];
            this.commercialValue = _data["commercialValue"];
            this.frequency = _data["frequency"];
            this.isInActiveCart = _data["isInActiveCart"];
            this.isAlreadyPurchased = _data["isAlreadyPurchased"];
            this.parameterDataType = _data["parameterDataType"] ? ParameterDataType.fromJS(_data["parameterDataType"]) : new ParameterDataType();
            this.contentComment = _data["contentComment"];
            if (Array.isArray(_data["documentList"])) {
                this.documentList = [] as any;
                for (let item of _data["documentList"])
                    this.documentList.push(item);
            }
        }
    }

    static fromJS(data: any): PurchaseParameterDataRecordDto {
        data = typeof data === 'object' ? data : {};
        let result = new PurchaseParameterDataRecordDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parameterDataId"] = this.parameterDataId;
        data["parameterId"] = this.parameterId;
        data["name"] = this.name;
        data["description"] = this.description;
        data["location"] = this.location;
        data["dataProvider"] = this.dataProvider;
        data["value"] = this.value;
        data["unit"] = this.unit;
        data["validTimeDuration"] = this.validTimeDuration;
        data["dataValidFrom"] = this.dataValidFrom ? this.dataValidFrom.toISOString() : <any>undefined;
        data["dataValidTo"] = this.dataValidTo ? this.dataValidTo.toISOString() : <any>undefined;
        data["isPublicData"] = this.isPublicData;
        data["commercialValue"] = this.commercialValue;
        data["frequency"] = this.frequency;
        data["isInActiveCart"] = this.isInActiveCart;
        data["isAlreadyPurchased"] = this.isAlreadyPurchased;
        data["parameterDataType"] = this.parameterDataType ? this.parameterDataType.toJSON() : <any>undefined;
        data["contentComment"] = this.contentComment;
        if (Array.isArray(this.documentList)) {
            data["documentList"] = [];
            for (let item of this.documentList)
                data["documentList"].push(item);
        }
        return data; 
    }

    clone(): PurchaseParameterDataRecordDto {
        const json = this.toJSON();
        let result = new PurchaseParameterDataRecordDto();
        result.init(json);
        return result;
    }
}

export interface IPurchaseParameterDataRecordDto {
    parameterDataId: number;
    parameterId: number;
    name: string;
    description: string;
    location: any;
    dataProvider: string;
    value: string;
    unit: string;
    validTimeDuration: string;
    dataValidFrom: moment.Moment;
    dataValidTo: moment.Moment;
    isPublicData: boolean;
    commercialValue: number;
    frequency: string;
    isInActiveCart: boolean;
    isAlreadyPurchased: boolean;
    parameterDataType: ParameterDataType;
    contentComment: string;
    documentList: any[];
}

export class ShoppingCartUpdateResponseDto implements IShoppingCartUpdateResponseDto {
    isSuccess: boolean;
    message: string;
    totalItems: number;
    totalPrice: number;
    cartItemList: any[];

    constructor(data?: IShoppingCartUpdateResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.cartItemList = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.isSuccess = _data["isSuccess"];
            this.message = _data["message"];
            this.totalItems = _data["totalItems"];
            this.totalPrice = _data["totalPrice"];
            if (Array.isArray(_data["cartItemList"])) {
                this.cartItemList = [] as any;
                for (let item of _data["cartItemList"])
                    this.cartItemList.push(item);
            }
        }
    }

    static fromJS(data: any): ShoppingCartUpdateResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartUpdateResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["isSuccess"] = this.isSuccess;
        data["message"] = this.message;
        data["totalItems"] = this.totalItems;
        data["totalPrice"] = this.totalPrice;
        if (Array.isArray(this.cartItemList)) {
            data["cartItemList"] = [];
            for (let item of this.cartItemList)
                data["cartItemList"].push(item);
        }
        return data; 
    }

    clone(): ShoppingCartUpdateResponseDto {
        const json = this.toJSON();
        let result = new ShoppingCartUpdateResponseDto();
        result.init(json);
        return result;
    }
}

export interface IShoppingCartUpdateResponseDto {
    isSuccess: boolean;
    message: string;
    totalItems: number;
    totalPrice: number;
    cartItemList: any[];
}

export class GetManyShoppingCartResponseDto implements IGetManyShoppingCartResponseDto {
    data: ShoppingCart[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyShoppingCartResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ShoppingCart.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyShoppingCartResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyShoppingCartResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyShoppingCartResponseDto {
        const json = this.toJSON();
        let result = new GetManyShoppingCartResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyShoppingCartResponseDto {
    data: ShoppingCart[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class ShoppingCartItem implements IShoppingCartItem {
    id: number;
    shoppingCart: ShoppingCart;
    parameterLocationDataId: number;
    parameterId: number;
    parameterName: string;
    parameterDescription: string;
    parameterLocation: string;
    dataProvider: string;
    value: string;
    unit: string;
    dataValidFrom: moment.Moment;
    dataValidTo: moment.Moment;
    price: number;
    frequency: string;
    isActiveInCart: boolean;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ShoppingCartItemStatus;

    constructor(data?: IShoppingCartItem) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.shoppingCart = new ShoppingCart();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.shoppingCart = _data["shoppingCart"] ? ShoppingCart.fromJS(_data["shoppingCart"]) : new ShoppingCart();
            this.parameterLocationDataId = _data["parameterLocationDataId"];
            this.parameterId = _data["parameterId"];
            this.parameterName = _data["parameterName"];
            this.parameterDescription = _data["parameterDescription"];
            this.parameterLocation = _data["parameterLocation"];
            this.dataProvider = _data["dataProvider"];
            this.value = _data["value"];
            this.unit = _data["unit"];
            this.dataValidFrom = _data["dataValidFrom"] ? moment(_data["dataValidFrom"].toString()) : <any>undefined;
            this.dataValidTo = _data["dataValidTo"] ? moment(_data["dataValidTo"].toString()) : <any>undefined;
            this.price = _data["price"];
            this.frequency = _data["frequency"];
            this.isActiveInCart = _data["isActiveInCart"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ShoppingCartItem {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartItem();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["shoppingCart"] = this.shoppingCart ? this.shoppingCart.toJSON() : <any>undefined;
        data["parameterLocationDataId"] = this.parameterLocationDataId;
        data["parameterId"] = this.parameterId;
        data["parameterName"] = this.parameterName;
        data["parameterDescription"] = this.parameterDescription;
        data["parameterLocation"] = this.parameterLocation;
        data["dataProvider"] = this.dataProvider;
        data["value"] = this.value;
        data["unit"] = this.unit;
        data["dataValidFrom"] = this.dataValidFrom ? this.dataValidFrom.toISOString() : <any>undefined;
        data["dataValidTo"] = this.dataValidTo ? this.dataValidTo.toISOString() : <any>undefined;
        data["price"] = this.price;
        data["frequency"] = this.frequency;
        data["isActiveInCart"] = this.isActiveInCart;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ShoppingCartItem {
        const json = this.toJSON();
        let result = new ShoppingCartItem();
        result.init(json);
        return result;
    }
}

export interface IShoppingCartItem {
    id: number;
    shoppingCart: ShoppingCart;
    parameterLocationDataId: number;
    parameterId: number;
    parameterName: string;
    parameterDescription: string;
    parameterLocation: string;
    dataProvider: string;
    value: string;
    unit: string;
    dataValidFrom: moment.Moment;
    dataValidTo: moment.Moment;
    price: number;
    frequency: string;
    isActiveInCart: boolean;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ShoppingCartItemStatus;
}

export class ShoppingCartPayment implements IShoppingCartPayment {
    id: number;
    transactionAmount: number;
    shoppingCart: ShoppingCart;
    isSuccess: boolean;
    transactionStatus: string;
    transactionReferenceNumber: string;
    paymentGatewayName: string;
    convenienceFee: string;
    note: string;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ShoppingCartPaymentStatus;

    constructor(data?: IShoppingCartPayment) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.shoppingCart = new ShoppingCart();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.transactionAmount = _data["TransactionAmount"];
            this.shoppingCart = _data["shoppingCart"] ? ShoppingCart.fromJS(_data["shoppingCart"]) : new ShoppingCart();
            this.isSuccess = _data["isSuccess"];
            this.transactionStatus = _data["TransactionStatus"];
            this.transactionReferenceNumber = _data["TransactionReferenceNumber"];
            this.paymentGatewayName = _data["PaymentGatewayName"];
            this.convenienceFee = _data["ConvenienceFee"];
            this.note = _data["Note"];
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ShoppingCartPayment {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCartPayment();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["TransactionAmount"] = this.transactionAmount;
        data["shoppingCart"] = this.shoppingCart ? this.shoppingCart.toJSON() : <any>undefined;
        data["isSuccess"] = this.isSuccess;
        data["TransactionStatus"] = this.transactionStatus;
        data["TransactionReferenceNumber"] = this.transactionReferenceNumber;
        data["PaymentGatewayName"] = this.paymentGatewayName;
        data["ConvenienceFee"] = this.convenienceFee;
        data["Note"] = this.note;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ShoppingCartPayment {
        const json = this.toJSON();
        let result = new ShoppingCartPayment();
        result.init(json);
        return result;
    }
}

export interface IShoppingCartPayment {
    id: number;
    transactionAmount: number;
    shoppingCart: ShoppingCart;
    isSuccess: boolean;
    transactionStatus: string;
    transactionReferenceNumber: string;
    paymentGatewayName: string;
    convenienceFee: string;
    note: string;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ShoppingCartPaymentStatus;
}

export class ShoppingCart implements IShoppingCart {
    id: number;
    userEmail: string;
    sessionId: string;
    token: string;
    cartStatus: ShoppingCartCartStatus;
    firstName: string;
    lastName: string;
    phoneNumber: string;
    email: string;
    streetAddress: string;
    city: string;
    province: string;
    postalCode: number;
    country: string;
    cartItems: ShoppingCartItem[];
    shoppingCartPayments: ShoppingCartPayment[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ShoppingCartStatus;

    constructor(data?: IShoppingCart) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.cartItems = [];
            this.shoppingCartPayments = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.userEmail = _data["userEmail"];
            this.sessionId = _data["sessionId"];
            this.token = _data["token"];
            this.cartStatus = _data["cartStatus"];
            this.firstName = _data["firstName"];
            this.lastName = _data["lastName"];
            this.phoneNumber = _data["phoneNumber"];
            this.email = _data["email"];
            this.streetAddress = _data["streetAddress"];
            this.city = _data["city"];
            this.province = _data["province"];
            this.postalCode = _data["postalCode"];
            this.country = _data["country"];
            if (Array.isArray(_data["cartItems"])) {
                this.cartItems = [] as any;
                for (let item of _data["cartItems"])
                    this.cartItems.push(ShoppingCartItem.fromJS(item));
            }
            if (Array.isArray(_data["shoppingCartPayments"])) {
                this.shoppingCartPayments = [] as any;
                for (let item of _data["shoppingCartPayments"])
                    this.shoppingCartPayments.push(ShoppingCartPayment.fromJS(item));
            }
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ShoppingCart {
        data = typeof data === 'object' ? data : {};
        let result = new ShoppingCart();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["userEmail"] = this.userEmail;
        data["sessionId"] = this.sessionId;
        data["token"] = this.token;
        data["cartStatus"] = this.cartStatus;
        data["firstName"] = this.firstName;
        data["lastName"] = this.lastName;
        data["phoneNumber"] = this.phoneNumber;
        data["email"] = this.email;
        data["streetAddress"] = this.streetAddress;
        data["city"] = this.city;
        data["province"] = this.province;
        data["postalCode"] = this.postalCode;
        data["country"] = this.country;
        if (Array.isArray(this.cartItems)) {
            data["cartItems"] = [];
            for (let item of this.cartItems)
                data["cartItems"].push(item.toJSON());
        }
        if (Array.isArray(this.shoppingCartPayments)) {
            data["shoppingCartPayments"] = [];
            for (let item of this.shoppingCartPayments)
                data["shoppingCartPayments"].push(item.toJSON());
        }
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ShoppingCart {
        const json = this.toJSON();
        let result = new ShoppingCart();
        result.init(json);
        return result;
    }
}

export interface IShoppingCart {
    id: number;
    userEmail: string;
    sessionId: string;
    token: string;
    cartStatus: ShoppingCartCartStatus;
    firstName: string;
    lastName: string;
    phoneNumber: string;
    email: string;
    streetAddress: string;
    city: string;
    province: string;
    postalCode: number;
    country: string;
    cartItems: ShoppingCartItem[];
    shoppingCartPayments: ShoppingCartPayment[];
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ShoppingCartStatus;
}

export class CreateManyShoppingCartDto implements ICreateManyShoppingCartDto {
    bulk: ShoppingCart[];

    constructor(data?: ICreateManyShoppingCartDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ShoppingCart.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyShoppingCartDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyShoppingCartDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyShoppingCartDto {
        const json = this.toJSON();
        let result = new CreateManyShoppingCartDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyShoppingCartDto {
    bulk: ShoppingCart[];
}

export class CreateManyProjectProgrammeDto implements ICreateManyProjectProgrammeDto {
    bulk: ProjectProgramme[];

    constructor(data?: ICreateManyProjectProgrammeDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ProjectProgramme.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyProjectProgrammeDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyProjectProgrammeDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyProjectProgrammeDto {
        const json = this.toJSON();
        let result = new CreateManyProjectProgrammeDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyProjectProgrammeDto {
    bulk: ProjectProgramme[];
}

export class GetManyProjectFundingDetailResponseDto implements IGetManyProjectFundingDetailResponseDto {
    data: ProjectFundingDetail[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyProjectFundingDetailResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(ProjectFundingDetail.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyProjectFundingDetailResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyProjectFundingDetailResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyProjectFundingDetailResponseDto {
        const json = this.toJSON();
        let result = new GetManyProjectFundingDetailResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyProjectFundingDetailResponseDto {
    data: ProjectFundingDetail[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class ProjectFundingDetail implements IProjectFundingDetail {
    id: number;
    projectProgrammeId: number;
    donor: string;
    donorType: ProjectFundingDetailDonorType;
    initialInvestment: number;
    initialInvestmentCurrency: Currency;
    annualFunding: number;
    annualFundingCurrency: Currency;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProjectFundingDetailStatus;

    constructor(data?: IProjectFundingDetail) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.projectProgrammeId = _data["projectProgrammeId"];
            this.donor = _data["donor"];
            this.donorType = _data["donorType"];
            this.initialInvestment = _data["initialInvestment"];
            this.initialInvestmentCurrency = _data["initialInvestmentCurrency"] ? Currency.fromJS(_data["initialInvestmentCurrency"]) : <any>undefined;
            this.annualFunding = _data["annualFunding"];
            this.annualFundingCurrency = _data["annualFundingCurrency"] ? Currency.fromJS(_data["annualFundingCurrency"]) : <any>undefined;
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): ProjectFundingDetail {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectFundingDetail();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["projectProgrammeId"] = this.projectProgrammeId;
        data["donor"] = this.donor;
        data["donorType"] = this.donorType;
        data["initialInvestment"] = this.initialInvestment;
        data["initialInvestmentCurrency"] = this.initialInvestmentCurrency ? this.initialInvestmentCurrency.toJSON() : <any>undefined;
        data["annualFunding"] = this.annualFunding;
        data["annualFundingCurrency"] = this.annualFundingCurrency ? this.annualFundingCurrency.toJSON() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): ProjectFundingDetail {
        const json = this.toJSON();
        let result = new ProjectFundingDetail();
        result.init(json);
        return result;
    }
}

export interface IProjectFundingDetail {
    id: number;
    projectProgrammeId: number;
    donor: string;
    donorType: ProjectFundingDetailDonorType;
    initialInvestment: number;
    initialInvestmentCurrency: Currency;
    annualFunding: number;
    annualFundingCurrency: Currency;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: ProjectFundingDetailStatus;
}

export class CreateManyProjectFundingDetailDto implements ICreateManyProjectFundingDetailDto {
    bulk: ProjectFundingDetail[];

    constructor(data?: ICreateManyProjectFundingDetailDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ProjectFundingDetail.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyProjectFundingDetailDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyProjectFundingDetailDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyProjectFundingDetailDto {
        const json = this.toJSON();
        let result = new CreateManyProjectFundingDetailDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyProjectFundingDetailDto {
    bulk: ProjectFundingDetail[];
}

export class CreateManyPolicyDto implements ICreateManyPolicyDto {
    bulk: Policy[];

    constructor(data?: ICreateManyPolicyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Policy.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyPolicyDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyPolicyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyPolicyDto {
        const json = this.toJSON();
        let result = new CreateManyPolicyDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyPolicyDto {
    bulk: Policy[];
}

export class CreateManyProjectStatusDto implements ICreateManyProjectStatusDto {
    bulk: ProjectStatus[];

    constructor(data?: ICreateManyProjectStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ProjectStatus.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyProjectStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyProjectStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyProjectStatusDto {
        const json = this.toJSON();
        let result = new CreateManyProjectStatusDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyProjectStatusDto {
    bulk: ProjectStatus[];
}

export class CreateManyDocumentsDto implements ICreateManyDocumentsDto {
    bulk: Documents[];

    constructor(data?: ICreateManyDocumentsDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(Documents.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyDocumentsDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyDocumentsDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyDocumentsDto {
        const json = this.toJSON();
        let result = new CreateManyDocumentsDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyDocumentsDto {
    bulk: Documents[];
}

export class CreateManyProjectProgramDataDto implements ICreateManyProjectProgramDataDto {
    bulk: ProjectProgramData[];

    constructor(data?: ICreateManyProjectProgramDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(ProjectProgramData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyProjectProgramDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyProjectProgramDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyProjectProgramDataDto {
        const json = this.toJSON();
        let result = new CreateManyProjectProgramDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyProjectProgramDataDto {
    bulk: ProjectProgramData[];
}

export class ProjectDataAssignRequest implements IProjectDataAssignRequest {
    requestIdList: number[];
    dataEntryUser: User;
    dataRequestStatus: DataRequestStatus;
    dataEntryDeadline: moment.Moment;
    tempUserId: number;
    comment: string;

    constructor(data?: IProjectDataAssignRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.requestIdList = [];
            this.dataEntryUser = new User();
            this.dataRequestStatus = new DataRequestStatus();
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["requestIdList"])) {
                this.requestIdList = [] as any;
                for (let item of _data["requestIdList"])
                    this.requestIdList.push(item);
            }
            this.dataEntryUser = _data["dataEntryUser"] ? User.fromJS(_data["dataEntryUser"]) : new User();
            this.dataRequestStatus = _data["dataRequestStatus"] ? DataRequestStatus.fromJS(_data["dataRequestStatus"]) : new DataRequestStatus();
            this.dataEntryDeadline = _data["dataEntryDeadline"] ? moment(_data["dataEntryDeadline"].toString()) : <any>undefined;
            this.tempUserId = _data["tempUserId"];
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): ProjectDataAssignRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDataAssignRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.requestIdList)) {
            data["requestIdList"] = [];
            for (let item of this.requestIdList)
                data["requestIdList"].push(item);
        }
        data["dataEntryUser"] = this.dataEntryUser ? this.dataEntryUser.toJSON() : <any>undefined;
        data["dataRequestStatus"] = this.dataRequestStatus ? this.dataRequestStatus.toJSON() : <any>undefined;
        data["dataEntryDeadline"] = this.dataEntryDeadline ? this.dataEntryDeadline.toISOString() : <any>undefined;
        data["tempUserId"] = this.tempUserId;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): ProjectDataAssignRequest {
        const json = this.toJSON();
        let result = new ProjectDataAssignRequest();
        result.init(json);
        return result;
    }
}

export interface IProjectDataAssignRequest {
    requestIdList: number[];
    dataEntryUser: User;
    dataRequestStatus: DataRequestStatus;
    dataEntryDeadline: moment.Moment;
    tempUserId: number;
    comment: string;
}

export class ProjectDataSaveRequest implements IProjectDataSaveRequest {
    projectProgramDataId: number;
    projectStatus: ProjectStatus;
    projectProgress: string;
    submitForReview: boolean;
    dataRequestStatus: DataRequestStatus;
    tempUserId: number;

    constructor(data?: IProjectDataSaveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.projectStatus = new ProjectStatus();
            this.dataRequestStatus = new DataRequestStatus();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.projectProgramDataId = _data["projectProgramDataId"];
            this.projectStatus = _data["projectStatus"] ? ProjectStatus.fromJS(_data["projectStatus"]) : new ProjectStatus();
            this.projectProgress = _data["projectProgress"];
            this.submitForReview = _data["submitForReview"];
            this.dataRequestStatus = _data["dataRequestStatus"] ? DataRequestStatus.fromJS(_data["dataRequestStatus"]) : new DataRequestStatus();
            this.tempUserId = _data["tempUserId"];
        }
    }

    static fromJS(data: any): ProjectDataSaveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new ProjectDataSaveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["projectProgramDataId"] = this.projectProgramDataId;
        data["projectStatus"] = this.projectStatus ? this.projectStatus.toJSON() : <any>undefined;
        data["projectProgress"] = this.projectProgress;
        data["submitForReview"] = this.submitForReview;
        data["dataRequestStatus"] = this.dataRequestStatus ? this.dataRequestStatus.toJSON() : <any>undefined;
        data["tempUserId"] = this.tempUserId;
        return data; 
    }

    clone(): ProjectDataSaveRequest {
        const json = this.toJSON();
        let result = new ProjectDataSaveRequest();
        result.init(json);
        return result;
    }
}

export interface IProjectDataSaveRequest {
    projectProgramDataId: number;
    projectStatus: ProjectStatus;
    projectProgress: string;
    submitForReview: boolean;
    dataRequestStatus: DataRequestStatus;
    tempUserId: number;
}

export class PolicyDataRequest implements IPolicyDataRequest {
    institutionIds: number[];
    year: number;
    deadline: moment.Moment;
    comment: string;

    constructor(data?: IPolicyDataRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.institutionIds = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["institutionIds"])) {
                this.institutionIds = [] as any;
                for (let item of _data["institutionIds"])
                    this.institutionIds.push(item);
            }
            this.year = _data["year"];
            this.deadline = _data["deadline"] ? moment(_data["deadline"].toString()) : <any>undefined;
            this.comment = _data["comment"];
        }
    }

    static fromJS(data: any): PolicyDataRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyDataRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.institutionIds)) {
            data["institutionIds"] = [];
            for (let item of this.institutionIds)
                data["institutionIds"].push(item);
        }
        data["year"] = this.year;
        data["deadline"] = this.deadline ? this.deadline.toISOString() : <any>undefined;
        data["comment"] = this.comment;
        return data; 
    }

    clone(): PolicyDataRequest {
        const json = this.toJSON();
        let result = new PolicyDataRequest();
        result.init(json);
        return result;
    }
}

export interface IPolicyDataRequest {
    institutionIds: number[];
    year: number;
    deadline: moment.Moment;
    comment: string;
}

export class PolicyDataSaveRequest implements IPolicyDataSaveRequest {
    policyDataId: number;
    amendments: string;
    submitForReview: boolean;
    dataRequestStatus: DataRequestStatus;
    tempUserId: number;

    constructor(data?: IPolicyDataSaveRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dataRequestStatus = new DataRequestStatus();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.policyDataId = _data["policyDataId"];
            this.amendments = _data["amendments"];
            this.submitForReview = _data["submitForReview"];
            this.dataRequestStatus = _data["dataRequestStatus"] ? DataRequestStatus.fromJS(_data["dataRequestStatus"]) : new DataRequestStatus();
            this.tempUserId = _data["tempUserId"];
        }
    }

    static fromJS(data: any): PolicyDataSaveRequest {
        data = typeof data === 'object' ? data : {};
        let result = new PolicyDataSaveRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["policyDataId"] = this.policyDataId;
        data["amendments"] = this.amendments;
        data["submitForReview"] = this.submitForReview;
        data["dataRequestStatus"] = this.dataRequestStatus ? this.dataRequestStatus.toJSON() : <any>undefined;
        data["tempUserId"] = this.tempUserId;
        return data; 
    }

    clone(): PolicyDataSaveRequest {
        const json = this.toJSON();
        let result = new PolicyDataSaveRequest();
        result.init(json);
        return result;
    }
}

export interface IPolicyDataSaveRequest {
    policyDataId: number;
    amendments: string;
    submitForReview: boolean;
    dataRequestStatus: DataRequestStatus;
    tempUserId: number;
}

export class CreateManyPolicyDataDto implements ICreateManyPolicyDataDto {
    bulk: PolicyData[];

    constructor(data?: ICreateManyPolicyDataDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(PolicyData.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyPolicyDataDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyPolicyDataDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyPolicyDataDto {
        const json = this.toJSON();
        let result = new CreateManyPolicyDataDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyPolicyDataDto {
    bulk: PolicyData[];
}

export class GetManyUserDataUsageCategoryResponseDto implements IGetManyUserDataUsageCategoryResponseDto {
    data: UserDataUsageCategory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;

    constructor(data?: IGetManyUserDataUsageCategoryResponseDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.data = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["data"])) {
                this.data = [] as any;
                for (let item of _data["data"])
                    this.data.push(UserDataUsageCategory.fromJS(item));
            }
            this.count = _data["count"];
            this.total = _data["total"];
            this.page = _data["page"];
            this.pageCount = _data["pageCount"];
        }
    }

    static fromJS(data: any): GetManyUserDataUsageCategoryResponseDto {
        data = typeof data === 'object' ? data : {};
        let result = new GetManyUserDataUsageCategoryResponseDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.data)) {
            data["data"] = [];
            for (let item of this.data)
                data["data"].push(item.toJSON());
        }
        data["count"] = this.count;
        data["total"] = this.total;
        data["page"] = this.page;
        data["pageCount"] = this.pageCount;
        return data; 
    }

    clone(): GetManyUserDataUsageCategoryResponseDto {
        const json = this.toJSON();
        let result = new GetManyUserDataUsageCategoryResponseDto();
        result.init(json);
        return result;
    }
}

export interface IGetManyUserDataUsageCategoryResponseDto {
    data: UserDataUsageCategory[];
    count: number;
    total: number;
    page: number;
    pageCount: number;
}

export class UserDataUsageCategory implements IUserDataUsageCategory {
    id: number;
    email: string;
    dataUsageCategory: DataUsageCategory;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: UserDataUsageCategoryStatus;

    constructor(data?: IUserDataUsageCategory) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.dataUsageCategory = new DataUsageCategory();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.email = _data["email"];
            this.dataUsageCategory = _data["dataUsageCategory"] ? DataUsageCategory.fromJS(_data["dataUsageCategory"]) : new DataUsageCategory();
            this.createdBy = _data["createdBy"];
            this.createdOn = _data["createdOn"] ? moment(_data["createdOn"].toString()) : <any>undefined;
            this.editedBy = _data["editedBy"];
            this.editedOn = _data["editedOn"] ? moment(_data["editedOn"].toString()) : <any>undefined;
            this.status = _data["status"];
        }
    }

    static fromJS(data: any): UserDataUsageCategory {
        data = typeof data === 'object' ? data : {};
        let result = new UserDataUsageCategory();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["email"] = this.email;
        data["dataUsageCategory"] = this.dataUsageCategory ? this.dataUsageCategory.toJSON() : <any>undefined;
        data["createdBy"] = this.createdBy;
        data["createdOn"] = this.createdOn ? this.createdOn.toISOString() : <any>undefined;
        data["editedBy"] = this.editedBy;
        data["editedOn"] = this.editedOn ? this.editedOn.toISOString() : <any>undefined;
        data["status"] = this.status;
        return data; 
    }

    clone(): UserDataUsageCategory {
        const json = this.toJSON();
        let result = new UserDataUsageCategory();
        result.init(json);
        return result;
    }
}

export interface IUserDataUsageCategory {
    id: number;
    email: string;
    dataUsageCategory: DataUsageCategory;
    createdBy: string;
    createdOn: moment.Moment;
    editedBy: string;
    editedOn: moment.Moment;
    status: UserDataUsageCategoryStatus;
}

export class CreateManyUserDataUsageCategoryDto implements ICreateManyUserDataUsageCategoryDto {
    bulk: UserDataUsageCategory[];

    constructor(data?: ICreateManyUserDataUsageCategoryDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.bulk = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["bulk"])) {
                this.bulk = [] as any;
                for (let item of _data["bulk"])
                    this.bulk.push(UserDataUsageCategory.fromJS(item));
            }
        }
    }

    static fromJS(data: any): CreateManyUserDataUsageCategoryDto {
        data = typeof data === 'object' ? data : {};
        let result = new CreateManyUserDataUsageCategoryDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.bulk)) {
            data["bulk"] = [];
            for (let item of this.bulk)
                data["bulk"].push(item.toJSON());
        }
        return data; 
    }

    clone(): CreateManyUserDataUsageCategoryDto {
        const json = this.toJSON();
        let result = new CreateManyUserDataUsageCategoryDto();
        result.init(json);
        return result;
    }
}

export interface ICreateManyUserDataUsageCategoryDto {
    bulk: UserDataUsageCategory[];
}

export enum UserTypeStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum InstitutionCategoryStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum InstitutionTypeStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ProvinceStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum HierarchyStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum DistrictStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum DivisionalSecretariatStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum InstitutionStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum UserStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum CurrencyStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum FinancingSchemeStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum SDBenefitStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ProjectStatusStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum SectorStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ClimateChangeDataCategoryStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum SubSectorStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ProjectTypeStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum DataRequestStatusStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum DocumentsDocumentOwner {
    ProjectProgramme = <any>"ProjectProgramme",
    Policy = <any>"Policy",
    ProjectProgramData = <any>"ProjectProgramData",
    PolicyData = <any>"PolicyData",
    Parameter = <any>"Parameter",
    ParameterLocationData = <any>"ParameterLocationData",
}

export enum DocumentsStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ProjectProgramDataStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ProjectProgrammeStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum DataUsageCategoryStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ClimateImpactStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum DeadlineStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum FrequencyStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum FrequencyDetailStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ParameterDataTypeStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum UomConversionStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum UnitOfMeasureStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum PolicyInfluence {
    National = <any>"National",
    Provincial = <any>"Provincial",
    DistrictLevel = <any>"DistrictLevel",
    CityLevel = <any>"CityLevel",
}

export enum PolicyStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ParameterDataCollectionLocation {
    Single = <any>"Single",
    All = <any>"All",
    Multiple = <any>"Multiple",
}

export enum ParameterDataCollectionGeography {
    National = <any>"National",
    Province = <any>"Province",
    District = <any>"District",
    DivisionalSecretariat = <any>"DivisionalSecretariat",
    Specificlocation = <any>"Specificlocation",
}

export enum ParameterStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ParameterLocationStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ParameterLocationDataStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum PolicyDataStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum DataRequestStatusHistoryStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum MitigationStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum SectorMOEStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ShoppingCartItemStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ShoppingCartPaymentStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ShoppingCartCartStatus {
    New = <any>"New",
    Checkout = <any>"Checkout",
    Paid = <any>"Paid",
    Complete = <any>"Complete",
    Abandoned = <any>"Abandoned",
}

export enum ShoppingCartStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum ProjectFundingDetailDonorType {
    Private = <any>"Private",
    Public = <any>"Public",
    International = <any>"International",
}

export enum ProjectFundingDetailStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export enum UserDataUsageCategoryStatus {
    Active = <any>"Active",
    Minus20 = <any>"-20",
    Minus10 = <any>"-10",
}

export class ApiException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}